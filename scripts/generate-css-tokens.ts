#!/usr/bin/env node
/**
 * CSS Token Generator
 * Automatically generates design-tokens.css from the TypeScript token definitions
 * This ensures consistency and eliminates duplication between JS and CSS tokens
 */

import * as fs from 'fs';
import * as path from 'path';
import * as tokens from '../src/styles/tokens/index';

// Tokens imported using ts-node















/**
 * Convert camelCase to kebab-case
 */
function toKebabCase(str) {
  return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
}

/**
 * Generate CSS custom properties from color tokens with RGB variants
 */
function generateColorTokens(colorObj, prefix = 'color') {
  let css = '';
  
  for (const [colorName, colorValues] of Object.entries(colorObj)) {
    if (typeof colorValues === 'object') {
      for (const [shade, value] of Object.entries(colorValues)) {
        css += `    --${prefix}-${toKebabCase(colorName)}-${shade}: ${value};\n`;
        // Generate RGB variants for rgba() usage
        if (value.startsWith('#')) {
          const rgbValue = hexToRgb(value);
          if (rgbValue) {
            css += `    --${prefix}-${toKebabCase(colorName)}-${shade}-rgb: ${rgbValue};\n`;
          }
        }
      }
    } else {
      css += `    --${prefix}-${toKebabCase(colorName)}: ${colorValues};\n`;
      // Generate RGB variant for rgba() usage
      if (colorValues.startsWith('#')) {
        const rgbValue = hexToRgb(colorValues);
        if (rgbValue) {
          css += `    --${prefix}-${toKebabCase(colorName)}-rgb: ${rgbValue};\n`;
        }
      }
    }
  }
  
  return css;
}

/**
 * Convert hex color to RGB values
 */
function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : null;
}

/**
 * Generate CSS custom properties from font tokens
 */
function generateFontTokens(fontObj) {
  let css = '';
  
  for (const [fontName, fontValue] of Object.entries(fontObj)) {
    css += `    --font-family-${toKebabCase(fontName)}: ${fontValue};\n`;
  }
  
  return css;
}

/**
 * Generate CSS custom properties from typography tokens
 */
function generateTypographyTokens(typographyObj) {
  let css = '';
  
  // Font sizes
  for (const [sizeName, sizeValue] of Object.entries(typographyObj.fontSizes)) {
    css += `    --font-size-${sizeName}: ${sizeValue};\n`;
  }
  
  // Font weights
  for (const [weightName, weightValue] of Object.entries(typographyObj.fontWeights)) {
    css += `    --font-${weightName}: ${weightValue};\n`;
  }
  
  return css;
}

/**
 * Generate CSS custom properties from spacing tokens
 */
function generateSpacingTokens(spacingObj) {
  let css = '';
  
  for (const [spaceName, spaceValue] of Object.entries(spacingObj)) {
    css += `    --spacing-${spaceName}: ${spaceValue};\n`;
  }
  
  return css;
}

/**
 * Generate CSS custom properties from border radius tokens
 */
function generateBorderRadiusTokens(radiusObj) {
  let css = '';
  
  for (const [radiusName, radiusValue] of Object.entries(radiusObj)) {
    css += `    --radius-${radiusName}: ${radiusValue};\n`;
  }
  
  return css;
}

/**
 * Generate CSS custom properties from shadow tokens
 */
function generateShadowTokens(shadowObj) {
  let css = '';
  
  for (const [shadowName, shadowValue] of Object.entries(shadowObj)) {
    css += `    --shadow-${shadowName}: ${shadowValue};\n`;
  }
  
  return css;
}

/**
 * Generate CSS custom properties from semantic color tokens
 */
function generateSemanticColorTokens(semanticObj) {
  let css = '';
  
  for (const [categoryName, categoryValues] of Object.entries(semanticObj)) {
    if (typeof categoryValues === 'object') {
      for (const [tokenName, tokenValue] of Object.entries(categoryValues)) {
        css += `    --color-${toKebabCase(categoryName)}-${toKebabCase(tokenName)}: ${tokenValue};\n`;
      }
    } else {
      css += `    --color-${toKebabCase(categoryName)}: ${categoryValues};\n`;
    }
  }
  
  return css;
}

/**
 * Generate the complete CSS file content
 */
function generateCSSTokens() {
  const header = `/**
 * Design Token System - CSS Variables
 * This file is auto-generated from the design tokens defined in index.ts
 * Do not edit this file directly - run 'npm run generate:tokens' instead
 */\n\n@layer tokens {\n  :root {\n`;
  
  const fontSection = `    /* Font Families */\n${generateFontTokens(tokens.fonts)}\n`;
  
  const typographySection = `    /* Typography Tokens */\n${generateTypographyTokens(tokens.typography)}\n`;
  
  const spacingSection = `    /* Spacing Tokens */\n${generateSpacingTokens(tokens.spacing)}\n`;
  
  const borderRadiusSection = `    /* Border Radius Tokens */\n${generateBorderRadiusTokens(tokens.borderRadius)}\n`;
  
  const shadowSection = `    /* Shadow Tokens */\n${generateShadowTokens(tokens.shadows)}\n`;
  
  const colorSection = `    /* Colors */\n${generateColorTokens(tokens.colors)}\n`;

  const colorAliasSection = `    /* Color Aliases */
    --color-primary: var(--color-primary-500);
    --color-secondary: var(--color-secondary-500);
    --color-accent: var(--color-accent-500);

    /* Background RGB aliases for rgba() usage */
    --background-rgb: var(--color-neutral-0-rgb);
    --background-dark-rgb: var(--color-neutral-800-rgb);
    --border-rgb: var(--color-neutral-200-rgb);
    --border-dark-rgb: var(--color-neutral-600-rgb);
    
    /* Shadow aliases */
    --shadow-color: var(--color-shadow-color);
    --shadow-color-dark: var(--color-neutral-800-rgb);

`;
  
  const semanticColorSection = `    /* Semantic Color Tokens */
${generateSemanticColorTokens(tokens.semanticColors.light)}`;

  const footer = `  }
`;

  const darkSection = `  .dark {
    /* Semantic Color Tokens for Dark Mode */
${generateSemanticColorTokens(tokens.semanticColors.dark)}
  }
}
`;

  return header + fontSection + typographySection + spacingSection + borderRadiusSection + shadowSection + colorSection + colorAliasSection + semanticColorSection + footer + darkSection;
}

/**
 * Write the generated CSS to the design-tokens.css file
 */
function writeTokensFile() {
  const cssContent = generateCSSTokens();
  const outputPath = path.join(__dirname, '../src/styles/tokens/design-tokens.css');
  
  try {
    fs.writeFileSync(outputPath, cssContent, 'utf8');
    console.log('‚úÖ Successfully generated design-tokens.css');
    console.log(`üìÅ Output: ${outputPath}`);
  } catch (error) {
    console.error('‚ùå Error writing design-tokens.css:', error.message);
    process.exit(1);
  }
}

// Run the generator
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

if (process.argv[1] === __filename) {
  writeTokensFile();
}

export {
  generateCSSTokens,
  writeTokensFile,
  generateColorTokens,
  generateFontTokens
};