import {c as createAstro,a as createComponent,r as renderTemplate,d as defineScriptVars,f as renderSlot,b as addAttribute,m as maybeRenderHead}from'./astro/server-CSpupoyF.js';import'kleur/colors';import'clsx';/* empty css                           */var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;
const $$Astro = createAstro("https://nosytlabs.com");
const $$AnimatedSection = createComponent(($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$AnimatedSection;
  const {
    animation = "fade-in",
    delay = 0,
    duration = 0.8,
    threshold = 0.1,
    once = true,
    stagger = false,
    staggerDelay = 0.1,
    class: className = "",
    id
  } = Astro2.props;
  const sectionId = id || `animated-section-${Math.random().toString(36).substring(2, 9)}`;
  return renderTemplate(_a || (_a = __template(["", "<section", "", "", "", "", "", "", "", "", " data-astro-cid-cch7oa3t> ", " </section>  <script>(function(){", "\n  document.addEventListener('DOMContentLoaded', () => {\n    const section = document.getElementById(sectionId);\n    if (!section) return;\n    \n    const animation = section.dataset.animation || 'fade-in';\n    const delay = parseFloat(section.dataset.delay || '0');\n    const duration = parseFloat(section.dataset.duration || '0.8');\n    const threshold = parseFloat(section.dataset.threshold || '0.1');\n    const once = section.dataset.once === 'true';\n    const stagger = section.dataset.stagger === 'true';\n    const staggerDelay = parseFloat(section.dataset.staggerDelay || '0.1');\n    \n    // Apply animation class\n    section.classList.add(`animate-${animation}`);\n    \n    // Set animation duration and delay\n    section.style.animationDuration = `${duration}s`;\n    section.style.animationDelay = `${delay}s`;\n    section.style.animationFillMode = 'forwards';\n    \n    // If staggered, prepare child elements\n    if (stagger) {\n      const children = Array.from(section.children);\n      children.forEach((child, index) => {\n        child.classList.add('staggered-child');\n        child.style.animationName = animation;\n        child.style.animationDuration = `${duration}s`;\n        child.style.animationDelay = `${delay + (index * staggerDelay)}s`;\n        child.style.animationFillMode = 'forwards';\n      });\n    }\n    \n    // Create Intersection Observer\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          // Animate the section\n          section.style.opacity = '1';\n          \n          // If staggered, animate children\n          if (stagger) {\n            const children = Array.from(section.children);\n            children.forEach((child, index) => {\n              setTimeout(() => {\n                child.style.opacity = '1';\n              }, index * (staggerDelay * 1000));\n            });\n          }\n          \n          // Unobserve if only animating once\n          if (once) {\n            observer.unobserve(section);\n          }\n        } else if (!once) {\n          // Reset animation if not once\n          section.style.opacity = '0';\n          \n          if (stagger) {\n            const children = Array.from(section.children);\n            children.forEach(child => {\n              child.style.opacity = '0';\n            });\n          }\n        }\n      });\n    }, { threshold });\n    \n    // Start observing\n    observer.observe(section);\n  });\n})();<\/script>"], ["", "<section", "", "", "", "", "", "", "", "", " data-astro-cid-cch7oa3t> ", " </section>  <script>(function(){", "\n  document.addEventListener('DOMContentLoaded', () => {\n    const section = document.getElementById(sectionId);\n    if (!section) return;\n    \n    const animation = section.dataset.animation || 'fade-in';\n    const delay = parseFloat(section.dataset.delay || '0');\n    const duration = parseFloat(section.dataset.duration || '0.8');\n    const threshold = parseFloat(section.dataset.threshold || '0.1');\n    const once = section.dataset.once === 'true';\n    const stagger = section.dataset.stagger === 'true';\n    const staggerDelay = parseFloat(section.dataset.staggerDelay || '0.1');\n    \n    // Apply animation class\n    section.classList.add(\\`animate-\\${animation}\\`);\n    \n    // Set animation duration and delay\n    section.style.animationDuration = \\`\\${duration}s\\`;\n    section.style.animationDelay = \\`\\${delay}s\\`;\n    section.style.animationFillMode = 'forwards';\n    \n    // If staggered, prepare child elements\n    if (stagger) {\n      const children = Array.from(section.children);\n      children.forEach((child, index) => {\n        child.classList.add('staggered-child');\n        child.style.animationName = animation;\n        child.style.animationDuration = \\`\\${duration}s\\`;\n        child.style.animationDelay = \\`\\${delay + (index * staggerDelay)}s\\`;\n        child.style.animationFillMode = 'forwards';\n      });\n    }\n    \n    // Create Intersection Observer\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          // Animate the section\n          section.style.opacity = '1';\n          \n          // If staggered, animate children\n          if (stagger) {\n            const children = Array.from(section.children);\n            children.forEach((child, index) => {\n              setTimeout(() => {\n                child.style.opacity = '1';\n              }, index * (staggerDelay * 1000));\n            });\n          }\n          \n          // Unobserve if only animating once\n          if (once) {\n            observer.unobserve(section);\n          }\n        } else if (!once) {\n          // Reset animation if not once\n          section.style.opacity = '0';\n          \n          if (stagger) {\n            const children = Array.from(section.children);\n            children.forEach(child => {\n              child.style.opacity = '0';\n            });\n          }\n        }\n      });\n    }, { threshold });\n    \n    // Start observing\n    observer.observe(section);\n  });\n})();<\/script>"])), maybeRenderHead(), addAttribute(sectionId, "id"), addAttribute(`animated-section ${className}`, "class"), addAttribute(animation, "data-animation"), addAttribute(delay, "data-delay"), addAttribute(duration, "data-duration"), addAttribute(threshold, "data-threshold"), addAttribute(once, "data-once"), addAttribute(stagger, "data-stagger"), addAttribute(staggerDelay, "data-stagger-delay"), renderSlot($$result, $$slots["default"]), defineScriptVars({ sectionId }));
}, "/mnt/persist/workspace/src/components/animations/AnimatedSection.astro", void 0);export{$$AnimatedSection as $};