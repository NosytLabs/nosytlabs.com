import { defineMiddleware } from 'astro:middleware';
import { validateCsrfFromRequest, createCsrfTokenForSession } from '../utils/csrf';
import { sequence } from 'astro:middleware';
import { MiddlewareComposer } from './core/MiddlewareComposer';
import { CsrfValidator } from './csrf/CsrfValidator';
import { SecurityErrorHandler } from './error/SecurityErrorHandler';
import { rateLimitMiddleware } from './rate-limit';
import { createSecurityContext } from './core/SecurityContext';

const composer = new MiddlewareComposer({
  enableRateLimit: true,
  enableCsrfProtection: true,
  enableSecurityHeaders: true,
});

composer.registerComponent('rateLimit', {
  name: 'rateLimit',
  priority: 100,
  execute: async (context, securityContext) => {
    const rateLimitResponse = await rateLimitMiddleware(context);
    if (rateLimitResponse) {
      return {
        shouldBlock: true,
        response: rateLimitResponse,
      };
    }
    return { shouldBlock: false };
  },
});

composer.registerComponent('csrf', {
  name: 'csrf',
  priority: 90,
  execute: (context, securityContext) => {
    const csrfValidator = new CsrfValidator();
    return csrfValidator.execute(context, securityContext);
  },
});

composer.registerComponent('securityHeaders', {
  name: 'securityHeaders',
  priority: 80,
  execute: async (context, securityContext) => {
    // This component now delegates to the SecurityHeadersManager at the end of the request.
    return { shouldBlock: false };
  },
});

export const onRequest = async (context: API.APIContext, next: () => Promise<Response>) => {
  const errorHandler = new SecurityErrorHandler();
  try {
    // Only apply HTTPS redirect in production
    if (import.meta.env.PROD) {
      try {
        const proto = context.request.headers.get('x-forwarded-proto');
        const host = context.request.headers.get('host');
        
        if (proto === 'http' && host) {
          return new Response(null, {
            status: 301,
            headers: {
              Location: `https://${host}${context.url.pathname}${context.url.search}`,
            },
          });
        }
      } catch (error) {
        console.warn('HTTPS redirect failed:', error);
      }
    }

    return await composer.execute(context, next);
  } catch (error) {
    const securityContext = createSecurityContext(context);
    return errorHandler.handleError(
      error instanceof Error ? error : new Error('Unknown error'),
      context,
      securityContext
    );
  }
};