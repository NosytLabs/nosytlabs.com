---
// Performance monitoring configuration
const config = {
  enabled: true,
  reportInterval: 5000, // 5 seconds
  thresholds: {
    lcp: 2500, // Largest Contentful Paint
    fid: 100,  // First Input Delay
    cls: 0.1,  // Cumulative Layout Shift
    fcp: 1800, // First Contentful Paint
    ttfb: 600, // Time to First Byte
  },
  enableRealTimeMonitoring: true,
  enableResourceMonitoring: true,
  enableErrorTracking: true,
  enableUserInteractionTracking: true,
  enableNetworkMonitoring: true,
  enableMemoryMonitoring: true,
  autoOptimize: true,
  reportToConsole: true,
  reportToAPI: false, // Set to true if you have an analytics endpoint
  apiEndpoint: '/api/performance',
};
---

<script define:vars={{ config }}>
class PerformanceMonitor {
  constructor(config) {
    this.config = config;
    this.metrics = {
      lcp: null,
      fid: null,
      cls: null,
      fcp: null,
      ttfb: null,
      loadTime: null,
      domContentLoaded: null,
      resourceCount: 0,
      totalResourceSize: 0,
      errorCount: 0,
      userInteractions: 0,
      memoryUsage: null,
      networkInfo: null,
    };
    this.observers = [];
    this.startTime = performance.now();
    this.isMonitoring = false;
    
    if (this.config.enabled) {
      this.init();
    }
  }

  init() {
    this.isMonitoring = true;
    this.setupCoreWebVitals();
    this.setupResourceMonitoring();
    this.setupErrorTracking();
    this.setupUserInteractionTracking();
    this.setupNetworkMonitoring();
    this.setupMemoryMonitoring();
    this.setupPerformanceObserver();
    this.startReporting();
    this.createStatusDisplay();
    
    if (this.config.autoOptimize) {
      this.enableAutoOptimizations();
    }
  }

  setupCoreWebVitals() {
    // Largest Contentful Paint (LCP)
    if ('PerformanceObserver' in window) {
      const lcpObserver = new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        const lastEntry = entries[entries.length - 1];
        this.metrics.lcp = lastEntry.startTime;
        this.checkThreshold('lcp', lastEntry.startTime);
      });
      
      try {
        lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
        this.observers.push(lcpObserver);
      } catch (e) {
        console.warn('LCP observer not supported:', e);
      }

      // First Input Delay (FID)
      const fidObserver = new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        entries.forEach(entry => {
          this.metrics.fid = entry.processingStart - entry.startTime;
          this.checkThreshold('fid', this.metrics.fid);
        });
      });
      
      try {
        fidObserver.observe({ entryTypes: ['first-input'] });
        this.observers.push(fidObserver);
      } catch (e) {
        console.warn('FID observer not supported:', e);
      }

      // Cumulative Layout Shift (CLS)
      let clsValue = 0;
      const clsObserver = new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        entries.forEach(entry => {
          if (!entry.hadRecentInput) {
            clsValue += entry.value;
            this.metrics.cls = clsValue;
            this.checkThreshold('cls', clsValue);
          }
        });
      });
      
      try {
        clsObserver.observe({ entryTypes: ['layout-shift'] });
        this.observers.push(clsObserver);
      } catch (e) {
        console.warn('CLS observer not supported:', e);
      }

      // First Contentful Paint (FCP)
      const fcpObserver = new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        entries.forEach(entry => {
          if (entry.name === 'first-contentful-paint') {
            this.metrics.fcp = entry.startTime;
            this.checkThreshold('fcp', entry.startTime);
          }
        });
      });
      
      try {
        fcpObserver.observe({ entryTypes: ['paint'] });
        this.observers.push(fcpObserver);
      } catch (e) {
        console.warn('FCP observer not supported:', e);
      }
    }

    // Navigation timing for TTFB and load times
    window.addEventListener('load', () => {
      const navigation = performance.getEntriesByType('navigation')[0];
      if (navigation) {
        this.metrics.ttfb = navigation.responseStart - navigation.requestStart;
        this.metrics.loadTime = navigation.loadEventEnd - navigation.navigationStart;
        this.metrics.domContentLoaded = navigation.domContentLoadedEventEnd - navigation.navigationStart;
        
        this.checkThreshold('ttfb', this.metrics.ttfb);
      }
    });
  }

  setupResourceMonitoring() {
    if (!this.config.enableResourceMonitoring) return;

    const resourceObserver = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      entries.forEach(entry => {
        this.metrics.resourceCount++;
        if (entry.transferSize) {
          this.metrics.totalResourceSize += entry.transferSize;
        }
        
        // Check for slow resources
        if (entry.duration > 1000) {
          console.warn(`Slow resource detected: ${entry.name} (${entry.duration.toFixed(2)}ms)`);
        }
      });
    });
    
    try {
      resourceObserver.observe({ entryTypes: ['resource'] });
      this.observers.push(resourceObserver);
    } catch (e) {
      console.warn('Resource observer not supported:', e);
    }
  }

  setupErrorTracking() {
    if (!this.config.enableErrorTracking) return;

    window.addEventListener('error', (event) => {
      this.metrics.errorCount++;
      console.error('Performance Monitor - Error detected:', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error
      });
    });

    window.addEventListener('unhandledrejection', (event) => {
      this.metrics.errorCount++;
      console.error('Performance Monitor - Unhandled promise rejection:', event.reason);
    });
  }

  setupUserInteractionTracking() {
    if (!this.config.enableUserInteractionTracking) return;

    ['click', 'keydown', 'scroll', 'touchstart'].forEach(eventType => {
      document.addEventListener(eventType, () => {
        this.metrics.userInteractions++;
      }, { passive: true });
    });
  }

  setupNetworkMonitoring() {
    if (!this.config.enableNetworkMonitoring) return;

    if ('connection' in navigator) {
      this.metrics.networkInfo = {
        effectiveType: navigator.connection.effectiveType,
        downlink: navigator.connection.downlink,
        rtt: navigator.connection.rtt,
        saveData: navigator.connection.saveData
      };

      navigator.connection.addEventListener('change', () => {
        this.metrics.networkInfo = {
          effectiveType: navigator.connection.effectiveType,
          downlink: navigator.connection.downlink,
          rtt: navigator.connection.rtt,
          saveData: navigator.connection.saveData
        };
      });
    }
  }

  setupMemoryMonitoring() {
    if (!this.config.enableMemoryMonitoring) return;

    if ('memory' in performance) {
      const updateMemoryInfo = () => {
        this.metrics.memoryUsage = {
          usedJSHeapSize: performance.memory.usedJSHeapSize,
          totalJSHeapSize: performance.memory.totalJSHeapSize,
          jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
        };
      };

      updateMemoryInfo();
      setInterval(updateMemoryInfo, this.config.reportInterval);
    }
  }

  setupPerformanceObserver() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        entries.forEach(entry => {
          if (entry.entryType === 'measure') {
            console.log(`Custom measure: ${entry.name} - ${entry.duration.toFixed(2)}ms`);
          }
        });
      });
      
      try {
        observer.observe({ entryTypes: ['measure'] });
        this.observers.push(observer);
      } catch (e) {
        console.warn('Performance observer not supported:', e);
      }
    }
  }

  checkThreshold(metric, value) {
    const threshold = this.config.thresholds[metric];
    if (threshold && value > threshold) {
      console.warn(`Performance threshold exceeded for ${metric}: ${value} > ${threshold}`);
      this.triggerOptimization(metric, value);
    }
  }

  triggerOptimization(metric, value) {
    if (!this.config.autoOptimize) return;

    switch (metric) {
      case 'lcp':
        this.optimizeLCP();
        break;
      case 'fid':
        this.optimizeFID();
        break;
      case 'cls':
        this.optimizeCLS();
        break;
      case 'fcp':
        this.optimizeFCP();
        break;
      case 'ttfb':
        this.optimizeTTFB();
        break;
    }
  }

  optimizeLCP() {
    // Preload critical resources
    const criticalImages = document.querySelectorAll('img[data-critical="true"]');
    criticalImages.forEach(img => {
      if (!img.loading) {
        img.loading = 'eager';
      }
    });

    // Optimize font loading
    const fontLinks = document.querySelectorAll('link[rel="preload"][as="font"]');
    if (fontLinks.length === 0) {
      const fonts = ['Inter', 'JetBrains Mono'];
      fonts.forEach(font => {
        const link = document.createElement('link');
        link.rel = 'preload';
        link.as = 'font';
        link.type = 'font/woff2';
        link.crossOrigin = 'anonymous';
        link.href = `/fonts/${font.toLowerCase().replace(' ', '-')}.woff2`;
        document.head.appendChild(link);
      });
    }
  }

  optimizeFID() {
    // Defer non-critical JavaScript
    const scripts = document.querySelectorAll('script:not([data-critical])');
    scripts.forEach(script => {
      if (!script.defer && !script.async) {
        script.defer = true;
      }
    });

    // Break up long tasks
    if ('scheduler' in window && 'postTask' in scheduler) {
      // Use scheduler API for better task scheduling
      console.log('Using scheduler API for task optimization');
    }
  }

  optimizeCLS() {
    // Add size attributes to images without them
    const images = document.querySelectorAll('img:not([width]):not([height])');
    images.forEach(img => {
      if (img.naturalWidth && img.naturalHeight) {
        img.width = img.naturalWidth;
        img.height = img.naturalHeight;
      }
    });

    // Reserve space for dynamic content
    const dynamicElements = document.querySelectorAll('[data-dynamic]');
    dynamicElements.forEach(element => {
      if (!element.style.minHeight) {
        element.style.minHeight = '200px';
      }
    });
  }

  optimizeFCP() {
    // Inline critical CSS
    const criticalCSS = document.querySelector('style[data-critical]');
    if (!criticalCSS) {
      const style = document.createElement('style');
      style.setAttribute('data-critical', 'true');
      style.textContent = `
        body { font-family: system-ui, -apple-system, sans-serif; }
        .hero { min-height: 60vh; }
        .container { max-width: 1200px; margin: 0 auto; }
      `;
      document.head.insertBefore(style, document.head.firstChild);
    }
  }

  optimizeTTFB() {
    // Enable service worker for caching
    if ('serviceWorker' in navigator && !navigator.serviceWorker.controller) {
      navigator.serviceWorker.register('/service-worker.js')
        .then(registration => {
          console.log('Service Worker registered for TTFB optimization');
        })
        .catch(error => {
          console.log('Service Worker registration failed:', error);
        });
    }
  }

  enableAutoOptimizations() {
    // Enable lazy loading for images
    const images = document.querySelectorAll('img:not([loading])');
    images.forEach(img => {
      img.loading = 'lazy';
    });

    // Add resource hints
    this.addResourceHints();

    // Optimize third-party scripts
    this.optimizeThirdPartyScripts();
  }

  addResourceHints() {
    const hints = [
      { rel: 'dns-prefetch', href: '//fonts.googleapis.com' },
      { rel: 'dns-prefetch', href: '//fonts.gstatic.com' },
      { rel: 'preconnect', href: 'https://fonts.googleapis.com' },
      { rel: 'preconnect', href: 'https://fonts.gstatic.com', crossorigin: true }
    ];

    hints.forEach(hint => {
      const existing = document.querySelector(`link[rel="${hint.rel}"][href="${hint.href}"]`);
      if (!existing) {
        const link = document.createElement('link');
        Object.assign(link, hint);
        document.head.appendChild(link);
      }
    });
  }

  optimizeThirdPartyScripts() {
    const thirdPartyScripts = document.querySelectorAll('script[src*="//"]');
    thirdPartyScripts.forEach(script => {
      if (!script.loading) {
        script.loading = 'lazy';
      }
    });
  }

  startReporting() {
    if (this.config.reportInterval > 0) {
      setInterval(() => {
        this.generateReport();
      }, this.config.reportInterval);
    }
  }

  generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      metrics: { ...this.metrics },
      performance: this.calculatePerformanceScore(),
      recommendations: this.generateRecommendations()
    };

    if (this.config.reportToConsole) {
      console.group('🚀 Performance Monitor Report');
      console.table(this.metrics);
      console.log('Performance Score:', report.performance.score);
      console.log('Recommendations:', report.recommendations);
      console.groupEnd();
    }

    if (this.config.reportToAPI && this.config.apiEndpoint) {
      this.sendToAPI(report);
    }

    this.updateStatusDisplay(report);
    return report;
  }

  calculatePerformanceScore() {
    let score = 100;
    const weights = {
      lcp: 25,
      fid: 25,
      cls: 25,
      fcp: 15,
      ttfb: 10
    };

    Object.entries(weights).forEach(([metric, weight]) => {
      const value = this.metrics[metric];
      const threshold = this.config.thresholds[metric];
      
      if (value !== null && threshold) {
        const ratio = value / threshold;
        if (ratio > 1) {
          score -= weight * Math.min(ratio - 1, 1);
        }
      }
    });

    return {
      score: Math.max(0, Math.round(score)),
      grade: this.getPerformanceGrade(score)
    };
  }

  getPerformanceGrade(score) {
    if (score >= 90) return 'A';
    if (score >= 80) return 'B';
    if (score >= 70) return 'C';
    if (score >= 60) return 'D';
    return 'F';
  }

  generateRecommendations() {
    const recommendations = [];

    if (this.metrics.lcp > this.config.thresholds.lcp) {
      recommendations.push('Optimize Largest Contentful Paint by preloading critical resources');
    }

    if (this.metrics.fid > this.config.thresholds.fid) {
      recommendations.push('Reduce First Input Delay by deferring non-critical JavaScript');
    }

    if (this.metrics.cls > this.config.thresholds.cls) {
      recommendations.push('Minimize Cumulative Layout Shift by setting image dimensions');
    }

    if (this.metrics.errorCount > 0) {
      recommendations.push(`Fix ${this.metrics.errorCount} JavaScript errors`);
    }

    if (this.metrics.totalResourceSize > 2000000) { // 2MB
      recommendations.push('Optimize resource sizes - total size exceeds 2MB');
    }

    return recommendations;
  }

  sendToAPI(report) {
    fetch(this.config.apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(report)
    }).catch(error => {
      console.error('Failed to send performance report:', error);
    });
  }

  createStatusDisplay() {
    const display = document.createElement('div');
    display.id = 'performance-monitor-status';
    display.className = 'performance-status';
    display.innerHTML = `
      <div class="performance-header">
        <span class="performance-icon">⚡</span>
        <span class="performance-title">Performance Monitor</span>
        <button class="performance-toggle" onclick="this.parentElement.parentElement.classList.toggle('minimized')">−</button>
      </div>
      <div class="performance-content">
        <div class="performance-score">Score: <span id="perf-score">--</span></div>
        <div class="performance-metrics">
          <div>LCP: <span id="perf-lcp">--</span>ms</div>
          <div>FID: <span id="perf-fid">--</span>ms</div>
          <div>CLS: <span id="perf-cls">--</span></div>
        </div>
        <div class="performance-status-text" id="perf-status">Monitoring...</div>
      </div>
    `;
    
    document.body.appendChild(display);
  }

  updateStatusDisplay(report) {
    const scoreElement = document.getElementById('perf-score');
    const lcpElement = document.getElementById('perf-lcp');
    const fidElement = document.getElementById('perf-fid');
    const clsElement = document.getElementById('perf-cls');
    const statusElement = document.getElementById('perf-status');

    if (scoreElement) scoreElement.textContent = report.performance.score;
    if (lcpElement) lcpElement.textContent = this.metrics.lcp ? Math.round(this.metrics.lcp) : '--';
    if (fidElement) fidElement.textContent = this.metrics.fid ? Math.round(this.metrics.fid) : '--';
    if (clsElement) clsElement.textContent = this.metrics.cls ? this.metrics.cls.toFixed(3) : '--';
    if (statusElement) {
      statusElement.textContent = report.recommendations.length > 0 
        ? `${report.recommendations.length} recommendations`
        : 'All metrics good';
    }
  }

  destroy() {
    this.isMonitoring = false;
    this.observers.forEach(observer => observer.disconnect());
    this.observers = [];
    
    const statusDisplay = document.getElementById('performance-monitor-status');
    if (statusDisplay) {
      statusDisplay.remove();
    }
  }
}

// Initialize performance monitor
if (typeof window !== 'undefined') {
  window.performanceMonitor = new PerformanceMonitor(config);
  
  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    if (window.performanceMonitor) {
      window.performanceMonitor.destroy();
    }
  });
}
</script>

<style>
.performance-status {
  position: fixed;
  top: 10px;
  left: 10px;
  z-index: 10000;
  background: rgba(0, 0, 0, 0.9);
  color: white;
  border-radius: 8px;
  padding: 0;
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
  min-width: 200px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  transition: all 0.3s ease;
}

.performance-status.minimized .performance-content {
  display: none;
}

.performance-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 8px 8px 0 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.performance-icon {
  font-size: 14px;
  margin-right: 6px;
}

.performance-title {
  font-weight: 600;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.performance-toggle {
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  font-size: 14px;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: background 0.2s ease;
}

.performance-toggle:hover {
  background: rgba(255, 255, 255, 0.2);
}

.performance-content {
  padding: 12px;
}

.performance-score {
  font-size: 14px;
  font-weight: 700;
  margin-bottom: 8px;
  color: #4ade80;
}

.performance-metrics {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 4px;
  margin-bottom: 8px;
}

.performance-metrics div {
  font-size: 10px;
  opacity: 0.8;
}

.performance-status-text {
  font-size: 10px;
  opacity: 0.7;
  font-style: italic;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .performance-status {
    top: 5px;
    left: 5px;
    min-width: 180px;
    font-size: 11px;
  }
  
  .performance-header {
    padding: 6px 10px;
  }
  
  .performance-content {
    padding: 10px;
  }
}

/* Hide in print */
@media print {
  .performance-status {
    display: none !important;
  }
}
</style>