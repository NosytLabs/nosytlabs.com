---
/**
 * Animation Optimizer Component
 * Provides optimized animations with performance monitoring and reduced motion support
 */

export interface Props {
  enableGPUAcceleration?: boolean;
  enableReducedMotion?: boolean;
  enablePerformanceMonitoring?: boolean;
  animationQuality?: 'low' | 'medium' | 'high';
  enableIntersectionObserver?: boolean;
}

const {
  enableGPUAcceleration = true,
  enableReducedMotion = true,
  enablePerformanceMonitoring = true,
  animationQuality = 'medium',
  enableIntersectionObserver = true
} = Astro.props;
---

<style is:inline>
/* ==========================================================================
   OPTIMIZED ANIMATION SYSTEM
   ========================================================================== */

/* GPU Acceleration Base Classes */
.gpu-accelerated {
  transform: translateZ(0);
  backface-visibility: hidden;
  perspective: 1000px;
  will-change: transform;
}

.gpu-accelerated-opacity {
  will-change: opacity, transform;
}

.gpu-accelerated-scale {
  will-change: transform, opacity;
}

/* Optimized Animation Classes */
.animate-fade-in-optimized {
  opacity: 0;
  animation: fadeInOptimized 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

.animate-slide-up-optimized {
  opacity: 0;
  transform: translateY(30px) translateZ(0);
  animation: slideUpOptimized 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

.animate-slide-down-optimized {
  opacity: 0;
  transform: translateY(-30px) translateZ(0);
  animation: slideDownOptimized 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

.animate-scale-in-optimized {
  opacity: 0;
  transform: scale(0.95) translateZ(0);
  animation: scaleInOptimized 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

.animate-bounce-optimized {
  animation: bounceOptimized 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}

.animate-pulse-optimized {
  animation: pulseOptimized 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.animate-spin-optimized {
  animation: spinOptimized 1s linear infinite;
  transform-origin: center;
}

/* Keyframe Animations */
@keyframes fadeInOptimized {
  to {
    opacity: 1;
  }
}

@keyframes slideUpOptimized {
  to {
    opacity: 1;
    transform: translateY(0) translateZ(0);
  }
}

@keyframes slideDownOptimized {
  to {
    opacity: 1;
    transform: translateY(0) translateZ(0);
  }
}

@keyframes scaleInOptimized {
  to {
    opacity: 1;
    transform: scale(1) translateZ(0);
  }
}

@keyframes bounceOptimized {
  0%, 20%, 53%, 80%, 100% {
    transform: translateY(0) translateZ(0);
  }
  40%, 43% {
    transform: translateY(-30px) translateZ(0);
  }
  70% {
    transform: translateY(-15px) translateZ(0);
  }
  90% {
    transform: translateY(-4px) translateZ(0);
  }
}

@keyframes pulseOptimized {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@keyframes spinOptimized {
  from {
    transform: rotate(0deg) translateZ(0);
  }
  to {
    transform: rotate(360deg) translateZ(0);
  }
}

/* Staggered Animation Delays */
.animate-delay-75 { animation-delay: 75ms; }
.animate-delay-100 { animation-delay: 100ms; }
.animate-delay-150 { animation-delay: 150ms; }
.animate-delay-200 { animation-delay: 200ms; }
.animate-delay-300 { animation-delay: 300ms; }
.animate-delay-500 { animation-delay: 500ms; }
.animate-delay-700 { animation-delay: 700ms; }
.animate-delay-1000 { animation-delay: 1000ms; }

/* Animation Duration Utilities */
.animate-duration-75 { animation-duration: 75ms; }
.animate-duration-100 { animation-duration: 100ms; }
.animate-duration-150 { animation-duration: 150ms; }
.animate-duration-200 { animation-duration: 200ms; }
.animate-duration-300 { animation-duration: 300ms; }
.animate-duration-500 { animation-duration: 500ms; }
.animate-duration-700 { animation-duration: 700ms; }
.animate-duration-1000 { animation-duration: 1000ms; }

/* Hover Animations */
.hover-lift {
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.hover-lift:hover {
  transform: translateY(-4px) translateZ(0);
}

.hover-scale {
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.hover-scale:hover {
  transform: scale(1.05) translateZ(0);
}

.hover-glow {
  transition: box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.hover-glow:hover {
  box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
}

/* Intersection Observer Animations */
.animate-on-scroll {
  opacity: 0;
  transform: translateY(30px) translateZ(0);
  transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
              transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.animate-on-scroll.in-view {
  opacity: 1;
  transform: translateY(0) translateZ(0);
}

/* Performance Quality Settings */
.animation-quality-low {
  animation-duration: 0.2s !important;
  transition-duration: 0.2s !important;
}

.animation-quality-medium {
  animation-duration: 0.4s !important;
  transition-duration: 0.4s !important;
}

.animation-quality-high {
  animation-duration: 0.6s !important;
  transition-duration: 0.6s !important;
}

/* Reduced Motion Support */
@media (prefers-reduced-motion: reduce) {
  .animate-fade-in-optimized,
  .animate-slide-up-optimized,
  .animate-slide-down-optimized,
  .animate-scale-in-optimized,
  .animate-bounce-optimized,
  .animate-pulse-optimized,
  .animate-spin-optimized,
  .animate-on-scroll {
    animation: none !important;
    transition: none !important;
    opacity: 1 !important;
    transform: none !important;
  }
  
  .hover-lift:hover,
  .hover-scale:hover {
    transform: none !important;
  }
}

/* Mobile Optimizations */
@media (max-width: 768px) {
  .animate-fade-in-optimized,
  .animate-slide-up-optimized,
  .animate-slide-down-optimized,
  .animate-scale-in-optimized {
    animation-duration: 0.3s;
  }
  
  .hover-lift:hover,
  .hover-scale:hover {
    transform: none; /* Disable hover effects on mobile */
  }
}

/* Dark Mode Adjustments */
@media (prefers-color-scheme: dark) {
  .hover-glow:hover {
    box-shadow: 0 10px 25px -5px rgba(255, 255, 255, 0.1), 
                0 10px 10px -5px rgba(255, 255, 255, 0.04);
  }
}
</style>

<script define:vars={{ 
  enableGPUAcceleration, 
  enableReducedMotion, 
  enablePerformanceMonitoring, 
  animationQuality, 
  enableIntersectionObserver 
}}>
  class AnimationOptimizer {
    constructor() {
      this.performanceMetrics = {
        animationFrames: 0,
        droppedFrames: 0,
        averageFPS: 0,
        lastFrameTime: performance.now()
      };
      
      this.intersectionObserver = null;
      this.reducedMotionQuery = null;
      
      this.init();
    }

    init() {
      this.setupReducedMotionDetection();
      this.setupGPUAcceleration();
      this.setupIntersectionObserver();
      this.setupPerformanceMonitoring();
      this.setupAnimationQuality();
      this.optimizeExistingAnimations();
    }

    setupReducedMotionDetection() {
      if (!enableReducedMotion) return;

      this.reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
      
      const handleReducedMotion = (e) => {
        document.body.classList.toggle('reduced-motion', e.matches);
        
        if (e.matches) {
          this.disableAnimations();
        } else {
          this.enableAnimations();
        }
      };

      this.reducedMotionQuery.addListener(handleReducedMotion);
      handleReducedMotion(this.reducedMotionQuery);
    }

    setupGPUAcceleration() {
      if (!enableGPUAcceleration) return;

      // Add GPU acceleration to animated elements
      const animatedElements = document.querySelectorAll([
        '[class*="animate-"]',
        '[class*="hover-"]',
        '.animate-on-scroll'
      ].join(', '));

      animatedElements.forEach(element => {
        element.classList.add('gpu-accelerated');
      });
    }

    setupIntersectionObserver() {
      if (!enableIntersectionObserver) return;

      const scrollAnimationElements = document.querySelectorAll('.animate-on-scroll');
      
      if (scrollAnimationElements.length === 0) return;

      this.intersectionObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('in-view');
            
            // Add staggered delay for multiple elements
            const delay = Array.from(entry.target.parentElement?.children || [])
              .indexOf(entry.target) * 100;
            
            if (delay > 0) {
              entry.target.style.animationDelay = `${delay}ms`;
            }
            
            this.intersectionObserver.unobserve(entry.target);
          }
        });
      }, {
        threshold: 0.1,
        rootMargin: '50px 0px'
      });

      scrollAnimationElements.forEach(element => {
        this.intersectionObserver.observe(element);
      });
    }

    setupPerformanceMonitoring() {
      if (!enablePerformanceMonitoring) return;

      let frameCount = 0;
      let lastTime = performance.now();

      const measurePerformance = (currentTime) => {
        frameCount++;
        
        if (currentTime - lastTime >= 1000) {
          this.performanceMetrics.averageFPS = Math.round(frameCount * 1000 / (currentTime - lastTime));
          this.performanceMetrics.animationFrames += frameCount;
          
          // Adjust animation quality based on performance
          this.adjustAnimationQuality();
          
          frameCount = 0;
          lastTime = currentTime;
        }
        
        requestAnimationFrame(measurePerformance);
      };

      requestAnimationFrame(measurePerformance);
    }

    setupAnimationQuality() {
      document.body.classList.add(`animation-quality-${animationQuality}`);
    }

    adjustAnimationQuality() {
      const fps = this.performanceMetrics.averageFPS;
      
      if (fps < 30) {
        // Low performance - reduce animation quality
        document.body.classList.remove('animation-quality-medium', 'animation-quality-high');
        document.body.classList.add('animation-quality-low');
      } else if (fps < 50) {
        // Medium performance
        document.body.classList.remove('animation-quality-low', 'animation-quality-high');
        document.body.classList.add('animation-quality-medium');
      } else {
        // High performance
        document.body.classList.remove('animation-quality-low', 'animation-quality-medium');
        document.body.classList.add('animation-quality-high');
      }
    }

    optimizeExistingAnimations() {
      // Find and optimize existing animations
      const animatedElements = document.querySelectorAll('*');
      
      animatedElements.forEach(element => {
        const computedStyle = window.getComputedStyle(element);
        
        // Check for animations or transitions
        if (computedStyle.animationName !== 'none' || computedStyle.transitionProperty !== 'none') {
          // Add GPU acceleration
          if (enableGPUAcceleration) {
            element.style.transform = element.style.transform || 'translateZ(0)';
            element.style.backfaceVisibility = 'hidden';
          }
          
          // Optimize will-change property
          this.optimizeWillChange(element);
        }
      });
    }

    optimizeWillChange(element) {
      const computedStyle = window.getComputedStyle(element);
      const willChange = computedStyle.willChange;
      
      if (willChange === 'auto' || willChange === '') {
        // Determine optimal will-change value
        if (computedStyle.transform !== 'none') {
          element.style.willChange = 'transform';
        } else if (computedStyle.opacity !== '1') {
          element.style.willChange = 'opacity';
        }
      }
    }

    disableAnimations() {
      const style = document.createElement('style');
      style.id = 'reduced-motion-override';
      style.textContent = `
        *, *::before, *::after {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
          scroll-behavior: auto !important;
        }
      `;
      document.head.appendChild(style);
    }

    enableAnimations() {
      const style = document.getElementById('reduced-motion-override');
      if (style) {
        style.remove();
      }
    }

    // Public API methods
    addScrollAnimation(element, animationType = 'fade-in') {
      element.classList.add('animate-on-scroll', `animate-${animationType}-optimized`);
      
      if (this.intersectionObserver) {
        this.intersectionObserver.observe(element);
      }
    }

    removeScrollAnimation(element) {
      element.classList.remove('animate-on-scroll');
      
      if (this.intersectionObserver) {
        this.intersectionObserver.unobserve(element);
      }
    }

    getPerformanceMetrics() {
      return { ...this.performanceMetrics };
    }

    destroy() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
      }
      
      if (this.reducedMotionQuery) {
        this.reducedMotionQuery.removeListener();
      }
    }
  }

  // Initialize Animation Optimizer
  let animationOptimizer;

  function initAnimationOptimizer() {
    animationOptimizer = new AnimationOptimizer();
    
    // Expose to global scope for external use
    window.animationOptimizer = animationOptimizer;
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAnimationOptimizer);
  } else {
    initAnimationOptimizer();
  }

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    if (animationOptimizer) {
      animationOptimizer.destroy();
    }
  });
</script>