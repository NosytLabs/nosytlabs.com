---
// Font preloading configuration
const config = {
  enabled: true,
  fonts: [
    {
      family: 'Inter',
      weights: [400, 500, 600, 700],
      styles: ['normal'],
      display: 'swap',
      preload: true,
      critical: true,
      formats: ['woff2', 'woff'],
      unicodeRange: 'U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD'
    },
    {
      family: 'JetBrains Mono',
      weights: [400, 500, 600],
      styles: ['normal'],
      display: 'swap',
      preload: true,
      critical: false,
      formats: ['woff2', 'woff'],
      unicodeRange: 'U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD'
    }
  ],
  fallbacks: {
    'Inter': 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
    'JetBrains Mono': '"SF Mono", Monaco, Inconsolata, "Roboto Mono", Consolas, "Courier New", monospace'
  },
  enableSubsetting: true,
  enableCompression: true,
  enableCaching: true,
  enableFallbackOptimization: true,
  enablePerformanceMonitoring: true,
  loadingStrategy: 'progressive', // 'progressive', 'critical-first', 'lazy'
  timeout: 3000, // Font loading timeout in ms
};

// Generate font URLs based on configuration
const generateFontUrls = (font) => {
  const urls = [];
  font.weights.forEach(weight => {
    font.styles.forEach(style => {
      font.formats.forEach(format => {
        const filename = `${font.family.toLowerCase().replace(/\s+/g, '-')}-${weight}${style !== 'normal' ? `-${style}` : ''}.${format}`;
        urls.push({
          url: `/fonts/${filename}`,
          format,
          weight,
          style,
          family: font.family
        });
      });
    });
  });
  return urls;
};

// Generate all font URLs
const allFontUrls = config.fonts.flatMap(generateFontUrls);
const criticalFonts = config.fonts.filter(font => font.critical);
const nonCriticalFonts = config.fonts.filter(font => !font.critical);
---

<!-- Critical font preloading -->
{config.enabled && criticalFonts.map(font => 
  font.weights.map(weight => 
    font.styles.map(style => (
      <link
        rel="preload"
        as="font"
        type="font/woff2"
        href={`/fonts/${font.family.toLowerCase().replace(/\s+/g, '-')}-${weight}${style !== 'normal' ? `-${style}` : ''}.woff2`}
        crossorigin="anonymous"
        data-font-family={font.family}
        data-font-weight={weight}
        data-font-style={style}
        data-critical="true"
      />
    ))
  )
)}

<!-- DNS prefetch for external font services -->
<link rel="dns-prefetch" href="//fonts.googleapis.com" />
<link rel="dns-prefetch" href="//fonts.gstatic.com" />
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

<!-- Font face declarations with optimizations -->
<style>
/* Font face declarations with progressive enhancement */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url('/fonts/inter-400.woff2') format('woff2'),
       url('/fonts/inter-400.woff') format('woff');
  unicode-range: U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;
  font-feature-settings: 'kern' 1, 'liga' 1, 'calt' 1, 'pnum' 1, 'tnum' 0, 'onum' 1, 'lnum' 0, 'dlig' 0;
}

@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 500;
  font-display: swap;
  src: url('/fonts/inter-500.woff2') format('woff2'),
       url('/fonts/inter-500.woff') format('woff');
  unicode-range: U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;
  font-feature-settings: 'kern' 1, 'liga' 1, 'calt' 1, 'pnum' 1, 'tnum' 0, 'onum' 1, 'lnum' 0, 'dlig' 0;
}

@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: url('/fonts/inter-600.woff2') format('woff2'),
       url('/fonts/inter-600.woff') format('woff');
  unicode-range: U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;
  font-feature-settings: 'kern' 1, 'liga' 1, 'calt' 1, 'pnum' 1, 'tnum' 0, 'onum' 1, 'lnum' 0, 'dlig' 0;
}

@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url('/fonts/inter-700.woff2') format('woff2'),
       url('/fonts/inter-700.woff') format('woff');
  unicode-range: U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;
  font-feature-settings: 'kern' 1, 'liga' 1, 'calt' 1, 'pnum' 1, 'tnum' 0, 'onum' 1, 'lnum' 0, 'dlig' 0;
}

@font-face {
  font-family: 'JetBrains Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url('/fonts/jetbrains-mono-400.woff2') format('woff2'),
       url('/fonts/jetbrains-mono-400.woff') format('woff');
  unicode-range: U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;
  font-feature-settings: 'kern' 1, 'liga' 1, 'calt' 1, 'pnum' 1, 'tnum' 0, 'onum' 1, 'lnum' 0, 'dlig' 0;
}

@font-face {
  font-family: 'JetBrains Mono';
  font-style: normal;
  font-weight: 500;
  font-display: swap;
  src: url('/fonts/jetbrains-mono-500.woff2') format('woff2'),
       url('/fonts/jetbrains-mono-500.woff') format('woff');
  unicode-range: U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;
  font-feature-settings: 'kern' 1, 'liga' 1, 'calt' 1, 'pnum' 1, 'tnum' 0, 'onum' 1, 'lnum' 0, 'dlig' 0;
}

@font-face {
  font-family: 'JetBrains Mono';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: url('/fonts/jetbrains-mono-600.woff2') format('woff2'),
       url('/fonts/jetbrains-mono-600.woff') format('woff');
  unicode-range: U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;
  font-feature-settings: 'kern' 1, 'liga' 1, 'calt' 1, 'pnum' 1, 'tnum' 0, 'onum' 1, 'lnum' 0, 'dlig' 0;
}

/* Fallback font optimization */
.font-inter-fallback {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.font-jetbrains-mono-fallback {
  font-family: "SF Mono", Monaco, Inconsolata, "Roboto Mono", Consolas, "Courier New", monospace;
}

/* Font loading states */
.fonts-loading {
  visibility: hidden;
}

.fonts-loaded {
  visibility: visible;
}

.fonts-failed {
  font-family: system-ui, -apple-system, sans-serif;
}

/* Critical font optimization */
.critical-text {
  font-family: 'Inter', system-ui, -apple-system, sans-serif;
  font-display: swap;
}

.code-text {
  font-family: 'JetBrains Mono', 'SF Mono', Monaco, Consolas, monospace;
  font-display: swap;
}

/* Performance optimizations */
.font-optimized {
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-kerning: auto;
  font-variant-ligatures: common-ligatures;
  font-feature-settings: 'kern' 1, 'liga' 1;
}

/* Responsive font sizing */
.responsive-text {
  font-size: clamp(1rem, 2.5vw, 1.25rem);
  line-height: 1.6;
}

/* Font loading animation */
@keyframes fontFadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.font-fade-in {
  animation: fontFadeIn 0.3s ease-out;
}
</style>

<script define:vars={{ config, allFontUrls }}>
class FontPreloader {
  constructor(config, fontUrls) {
    this.config = config;
    this.fontUrls = fontUrls;
    this.loadedFonts = new Set();
    this.failedFonts = new Set();
    this.loadingPromises = new Map();
    this.startTime = performance.now();
    this.isEnabled = config.enabled;
    
    if (this.isEnabled) {
      this.init();
    }
  }

  init() {
    this.setupFontLoadingDetection();
    this.setupPerformanceMonitoring();
    this.setupFallbackOptimization();
    this.loadFonts();
    this.setupFontLoadingStates();
    this.enableProgressiveEnhancement();
  }

  setupFontLoadingDetection() {
    // Use Font Loading API if available
    if ('fonts' in document) {
      document.fonts.addEventListener('loadingdone', (event) => {
        console.log('All fonts loaded:', event);
        this.onAllFontsLoaded();
      });

      document.fonts.addEventListener('loadingerror', (event) => {
        console.error('Font loading error:', event);
        this.onFontLoadingError(event);
      });
    }

    // Fallback detection using FontFace API
    this.setupFontFaceDetection();
  }

  setupFontFaceDetection() {
    if ('FontFace' in window) {
      this.config.fonts.forEach(fontConfig => {
        fontConfig.weights.forEach(weight => {
          fontConfig.styles.forEach(style => {
            const fontFace = new FontFace(
              fontConfig.family,
              `url('/fonts/${fontConfig.family.toLowerCase().replace(/\s+/g, '-')}-${weight}${style !== 'normal' ? `-${style}` : ''}.woff2')`,
              {
                weight: weight.toString(),
                style: style,
                display: fontConfig.display
              }
            );

            fontFace.load().then((loadedFace) => {
              document.fonts.add(loadedFace);
              this.onFontLoaded(fontConfig.family, weight, style);
            }).catch((error) => {
              console.error(`Failed to load font: ${fontConfig.family} ${weight} ${style}`, error);
              this.onFontFailed(fontConfig.family, weight, style);
            });
          });
        });
      });
    }
  }

  setupPerformanceMonitoring() {
    if (!this.config.enablePerformanceMonitoring) return;

    // Monitor font loading performance
    const observer = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      entries.forEach(entry => {
        if (entry.name.includes('/fonts/')) {
          console.log(`Font loaded: ${entry.name} in ${entry.duration.toFixed(2)}ms`);
          
          if (entry.duration > 1000) {
            console.warn(`Slow font loading detected: ${entry.name} took ${entry.duration.toFixed(2)}ms`);
          }
        }
      });
    });

    try {
      observer.observe({ entryTypes: ['resource'] });
    } catch (e) {
      console.warn('Performance observer not supported for font monitoring');
    }
  }

  setupFallbackOptimization() {
    if (!this.config.enableFallbackOptimization) return;

    // Apply fallback fonts immediately
    Object.entries(this.config.fallbacks).forEach(([fontFamily, fallback]) => {
      const elements = document.querySelectorAll(`[style*="font-family"][style*="${fontFamily}"], .font-${fontFamily.toLowerCase().replace(/\s+/g, '-')}`);
      elements.forEach(element => {
        const currentFontFamily = element.style.fontFamily || getComputedStyle(element).fontFamily;
        if (currentFontFamily.includes(fontFamily)) {
          element.style.fontFamily = `${fontFamily}, ${fallback}`;
        }
      });
    });
  }

  loadFonts() {
    const loadingStrategy = this.config.loadingStrategy;

    switch (loadingStrategy) {
      case 'critical-first':
        this.loadCriticalFirst();
        break;
      case 'lazy':
        this.loadLazy();
        break;
      case 'progressive':
      default:
        this.loadProgressive();
        break;
    }
  }

  loadCriticalFirst() {
    // Load critical fonts first
    const criticalFonts = this.config.fonts.filter(font => font.critical);
    const nonCriticalFonts = this.config.fonts.filter(font => !font.critical);

    Promise.all(criticalFonts.map(font => this.loadFont(font)))
      .then(() => {
        console.log('Critical fonts loaded');
        document.body.classList.add('critical-fonts-loaded');
        
        // Load non-critical fonts after critical ones
        setTimeout(() => {
          nonCriticalFonts.forEach(font => this.loadFont(font));
        }, 100);
      })
      .catch(error => {
        console.error('Critical font loading failed:', error);
        this.handleFontLoadingFailure();
      });
  }

  loadProgressive() {
    // Load fonts progressively with priority
    const sortedFonts = [...this.config.fonts].sort((a, b) => {
      if (a.critical && !b.critical) return -1;
      if (!a.critical && b.critical) return 1;
      return 0;
    });

    sortedFonts.forEach((font, index) => {
      setTimeout(() => {
        this.loadFont(font);
      }, index * 50); // Stagger loading by 50ms
    });
  }

  loadLazy() {
    // Load fonts when they're needed
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const fontFamily = entry.target.dataset.fontFamily;
          if (fontFamily) {
            const font = this.config.fonts.find(f => f.family === fontFamily);
            if (font) {
              this.loadFont(font);
              observer.unobserve(entry.target);
            }
          }
        }
      });
    });

    // Observe elements that use custom fonts
    document.querySelectorAll('[data-font-family]').forEach(element => {
      observer.observe(element);
    });
  }

  loadFont(fontConfig) {
    const fontKey = fontConfig.family;
    
    if (this.loadingPromises.has(fontKey)) {
      return this.loadingPromises.get(fontKey);
    }

    const promise = new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error(`Font loading timeout: ${fontConfig.family}`));
      }, this.config.timeout);

      if ('FontFace' in window) {
        const loadPromises = [];
        
        fontConfig.weights.forEach(weight => {
          fontConfig.styles.forEach(style => {
            const fontFace = new FontFace(
              fontConfig.family,
              `url('/fonts/${fontConfig.family.toLowerCase().replace(/\s+/g, '-')}-${weight}${style !== 'normal' ? `-${style}` : ''}.woff2')`,
              {
                weight: weight.toString(),
                style: style,
                display: fontConfig.display
              }
            );

            loadPromises.push(fontFace.load());
          });
        });

        Promise.all(loadPromises)
          .then((loadedFaces) => {
            clearTimeout(timeout);
            loadedFaces.forEach(face => document.fonts.add(face));
            this.onFontLoaded(fontConfig.family);
            resolve(fontConfig);
          })
          .catch((error) => {
            clearTimeout(timeout);
            this.onFontFailed(fontConfig.family);
            reject(error);
          });
      } else {
        // Fallback for browsers without FontFace API
        this.loadFontFallback(fontConfig)
          .then(() => {
            clearTimeout(timeout);
            resolve(fontConfig);
          })
          .catch((error) => {
            clearTimeout(timeout);
            reject(error);
          });
      }
    });

    this.loadingPromises.set(fontKey, promise);
    return promise;
  }

  loadFontFallback(fontConfig) {
    return new Promise((resolve, reject) => {
      const testString = 'abcdefghijklmnopqrstuvwxyz0123456789';
      const testSize = '72px';
      const fallbackFont = this.config.fallbacks[fontConfig.family] || 'serif';
      
      // Create test elements
      const container = document.createElement('div');
      container.style.position = 'absolute';
      container.style.left = '-9999px';
      container.style.top = '-9999px';
      container.style.visibility = 'hidden';
      
      const fallbackElement = document.createElement('span');
      fallbackElement.style.fontSize = testSize;
      fallbackElement.style.fontFamily = fallbackFont;
      fallbackElement.textContent = testString;
      
      const testElement = document.createElement('span');
      testElement.style.fontSize = testSize;
      testElement.style.fontFamily = `${fontConfig.family}, ${fallbackFont}`;
      testElement.textContent = testString;
      
      container.appendChild(fallbackElement);
      container.appendChild(testElement);
      document.body.appendChild(container);
      
      const fallbackWidth = fallbackElement.offsetWidth;
      const fallbackHeight = fallbackElement.offsetHeight;
      
      const checkFont = () => {
        const testWidth = testElement.offsetWidth;
        const testHeight = testElement.offsetHeight;
        
        if (testWidth !== fallbackWidth || testHeight !== fallbackHeight) {
          document.body.removeChild(container);
          resolve();
        } else {
          setTimeout(checkFont, 50);
        }
      };
      
      checkFont();
      
      // Timeout after specified duration
      setTimeout(() => {
        if (document.body.contains(container)) {
          document.body.removeChild(container);
          reject(new Error(`Font loading timeout: ${fontConfig.family}`));
        }
      }, this.config.timeout);
    });
  }

  onFontLoaded(fontFamily, weight, style) {
    const fontKey = `${fontFamily}-${weight}-${style}`;
    this.loadedFonts.add(fontKey);
    
    console.log(`Font loaded: ${fontKey}`);
    
    // Apply font to elements
    this.applyLoadedFont(fontFamily, weight, style);
    
    // Check if all fonts are loaded
    this.checkAllFontsLoaded();
  }

  onFontFailed(fontFamily, weight, style) {
    const fontKey = `${fontFamily}-${weight}-${style}`;
    this.failedFonts.add(fontKey);
    
    console.warn(`Font failed to load: ${fontKey}`);
    
    // Apply fallback
    this.applyFallbackFont(fontFamily);
  }

  applyLoadedFont(fontFamily, weight, style) {
    const elements = document.querySelectorAll(`[data-font-family="${fontFamily}"]`);
    elements.forEach(element => {
      element.classList.add('font-loaded');
      element.classList.add('font-fade-in');
    });
  }

  applyFallbackFont(fontFamily) {
    const fallback = this.config.fallbacks[fontFamily];
    if (fallback) {
      const elements = document.querySelectorAll(`[data-font-family="${fontFamily}"]`);
      elements.forEach(element => {
        element.style.fontFamily = fallback;
        element.classList.add('font-fallback');
      });
    }
  }

  checkAllFontsLoaded() {
    const totalFonts = this.config.fonts.reduce((total, font) => {
      return total + (font.weights.length * font.styles.length);
    }, 0);
    
    const loadedCount = this.loadedFonts.size;
    const failedCount = this.failedFonts.size;
    
    if (loadedCount + failedCount >= totalFonts) {
      this.onAllFontsLoaded();
    }
  }

  onAllFontsLoaded() {
    const loadTime = performance.now() - this.startTime;
    console.log(`All fonts processed in ${loadTime.toFixed(2)}ms`);
    
    document.body.classList.add('fonts-loaded');
    document.body.classList.remove('fonts-loading');
    
    // Trigger custom event
    const event = new CustomEvent('fontsloaded', {
      detail: {
        loadTime,
        loadedFonts: Array.from(this.loadedFonts),
        failedFonts: Array.from(this.failedFonts)
      }
    });
    document.dispatchEvent(event);
  }

  onFontLoadingError(error) {
    console.error('Font loading error:', error);
    this.handleFontLoadingFailure();
  }

  handleFontLoadingFailure() {
    document.body.classList.add('fonts-failed');
    document.body.classList.remove('fonts-loading');
    
    // Apply fallback fonts to all elements
    Object.entries(this.config.fallbacks).forEach(([fontFamily, fallback]) => {
      const elements = document.querySelectorAll(`[data-font-family="${fontFamily}"]`);
      elements.forEach(element => {
        element.style.fontFamily = fallback;
        element.classList.add('font-fallback');
      });
    });
  }

  setupFontLoadingStates() {
    // Add initial loading state
    document.body.classList.add('fonts-loading');
    
    // Remove loading state after timeout
    setTimeout(() => {
      if (document.body.classList.contains('fonts-loading')) {
        console.warn('Font loading timeout reached');
        this.handleFontLoadingFailure();
      }
    }, this.config.timeout);
  }

  enableProgressiveEnhancement() {
    // Add font optimization classes
    document.body.classList.add('font-optimized');
    
    // Enable font features
    const style = document.createElement('style');
    style.textContent = `
      .font-features {
        font-feature-settings: 'kern' 1, 'liga' 1, 'calt' 1;
        font-variant-numeric: oldstyle-nums;
        font-variant-ligatures: common-ligatures;
      }
    `;
    document.head.appendChild(style);
  }

  // Public API methods
  isLoaded(fontFamily) {
    return Array.from(this.loadedFonts).some(font => font.startsWith(fontFamily));
  }

  isFailed(fontFamily) {
    return Array.from(this.failedFonts).some(font => font.startsWith(fontFamily));
  }

  getLoadedFonts() {
    return Array.from(this.loadedFonts);
  }

  getFailedFonts() {
    return Array.from(this.failedFonts);
  }

  reload() {
    this.loadedFonts.clear();
    this.failedFonts.clear();
    this.loadingPromises.clear();
    this.startTime = performance.now();
    this.loadFonts();
  }
}

// Initialize font preloader
if (typeof window !== 'undefined' && config.enabled) {
  window.fontPreloader = new FontPreloader(config, allFontUrls);
  
  // Expose to global scope for debugging
  window.FontPreloader = FontPreloader;
}
</script>