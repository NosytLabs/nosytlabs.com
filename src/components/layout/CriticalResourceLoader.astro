---
/**
 * Critical Resource Loader Component
 * Optimizes loading of critical resources like CSS, fonts, and JavaScript
 */

export interface Props {
  criticalCSS?: string[];
  fonts?: Array<{
    family: string;
    weights?: number[];
    styles?: string[];
    display?: 'auto' | 'block' | 'swap' | 'fallback' | 'optional';
  }>;
  preloadImages?: string[];
  preloadScripts?: string[];
  deferredCSS?: string[];
  enableServiceWorker?: boolean;
  enableResourceHints?: boolean;
}

const {
  criticalCSS = [],
  fonts = [],
  preloadImages = [],
  preloadScripts = [],
  deferredCSS = [],
  enableServiceWorker = true,
  enableResourceHints = true
} = Astro.props;

// Generate font URLs
const generateFontUrls = (font: any) => {
  const weights = font.weights || [400];
  const styles = font.styles || ['normal'];
  const display = font.display || 'swap';
  
  return weights.flatMap(weight => 
    styles.map(style => 
      `https://fonts.googleapis.com/css2?family=${font.family.replace(' ', '+')}:wght@${weight}&display=${display}`
    )
  );
};
---

<!-- DNS Prefetch for external domains -->
{enableResourceHints && (
  <>
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">
    <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  </>
)}

<!-- Critical CSS Preloading -->
{criticalCSS.map(cssFile => (
  <link rel="preload" href={cssFile} as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href={cssFile}></noscript>
))}

<!-- Font Preloading -->
{fonts.map(font => 
  generateFontUrls(font).map(fontUrl => (
    <link rel="preload" href={fontUrl} as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href={fontUrl}></noscript>
  ))
)}

<!-- Image Preloading -->
{preloadImages.map(imageUrl => (
  <link rel="preload" href={imageUrl} as="image">
))}

<!-- Script Preloading -->
{preloadScripts.map(scriptUrl => (
  <link rel="preload" href={scriptUrl} as="script">
))}

<!-- Deferred CSS Loading -->
{deferredCSS.map(cssFile => (
  <link rel="preload" href={cssFile} as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href={cssFile}></noscript>
))}

<script define:vars={{ enableServiceWorker, preloadScripts, deferredCSS }}>
  // Critical Resource Loader Class
  class CriticalResourceLoader {
    constructor() {
      this.loadedResources = new Set();
      this.loadingPromises = new Map();
      this.init();
    }

    init() {
      // Initialize service worker if enabled
      if (enableServiceWorker && 'serviceWorker' in navigator) {
        this.registerServiceWorker();
      }

      // Setup resource loading strategies
      this.setupResourceLoading();
      
      // Monitor performance
      this.monitorPerformance();
      
      // Setup intersection observer for lazy loading
      this.setupLazyLoading();
    }

    async registerServiceWorker() {
      try {
        const registration = await navigator.serviceWorker.register('/sw.js');
        console.log('Service Worker registered:', registration);
        
        // Listen for updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New content available, notify user
              this.notifyUpdate();
            }
          });
        });
      } catch (error) {
        console.warn('Service Worker registration failed:', error);
      }
    }

    setupResourceLoading() {
      // Load critical scripts first
      if (preloadScripts.length > 0) {
        this.loadCriticalScripts();
      }

      // Load deferred CSS after critical resources
      if (deferredCSS.length > 0) {
        requestIdleCallback(() => {
          this.loadDeferredCSS();
        });
      }

      // Prefetch next page resources
      this.prefetchNextPageResources();
    }

    async loadCriticalScripts() {
      const loadPromises = preloadScripts.map(scriptUrl => this.loadScript(scriptUrl));
      
      try {
        await Promise.all(loadPromises);
        console.log('Critical scripts loaded');
      } catch (error) {
        console.error('Failed to load critical scripts:', error);
      }
    }

    loadScript(src) {
      if (this.loadedResources.has(src)) {
        return Promise.resolve();
      }

      if (this.loadingPromises.has(src)) {
        return this.loadingPromises.get(src);
      }

      const promise = new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        script.onload = () => {
          this.loadedResources.add(src);
          resolve();
        };
        script.onerror = reject;
        document.head.appendChild(script);
      });

      this.loadingPromises.set(src, promise);
      return promise;
    }

    loadDeferredCSS() {
      deferredCSS.forEach(cssFile => {
        if (!this.loadedResources.has(cssFile)) {
          const link = document.createElement('link');
          link.rel = 'stylesheet';
          link.href = cssFile;
          link.onload = () => this.loadedResources.add(cssFile);
          document.head.appendChild(link);
        }
      });
    }

    prefetchNextPageResources() {
      // Prefetch resources for likely next pages
      const links = document.querySelectorAll('a[href^="/"]');
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const link = entry.target;
            const href = link.getAttribute('href');
            
            // Create prefetch link
            const prefetchLink = document.createElement('link');
            prefetchLink.rel = 'prefetch';
            prefetchLink.href = href;
            document.head.appendChild(prefetchLink);
            
            observer.unobserve(link);
          }
        });
      }, { threshold: 0.1 });

      links.forEach(link => observer.observe(link));
    }

    setupLazyLoading() {
      // Enhanced lazy loading for images and iframes
      const lazyElements = document.querySelectorAll('[data-lazy]');
      
      if (lazyElements.length === 0) return;

      const lazyObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const element = entry.target;
            const src = element.dataset.lazy;
            
            if (element.tagName === 'IMG') {
              element.src = src;
            } else if (element.tagName === 'IFRAME') {
              element.src = src;
            }
            
            element.removeAttribute('data-lazy');
            lazyObserver.unobserve(element);
          }
        });
      }, {
        rootMargin: '50px 0px',
        threshold: 0.01
      });

      lazyElements.forEach(element => lazyObserver.observe(element));
    }

    monitorPerformance() {
      // Monitor Core Web Vitals
      if ('web-vitals' in window) {
        import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
          getCLS(this.sendToAnalytics);
          getFID(this.sendToAnalytics);
          getFCP(this.sendToAnalytics);
          getLCP(this.sendToAnalytics);
          getTTFB(this.sendToAnalytics);
        });
      }

      // Monitor resource loading times
      if ('PerformanceObserver' in window) {
        const observer = new PerformanceObserver((list) => {
          list.getEntries().forEach(entry => {
            if (entry.entryType === 'resource') {
              console.log(`Resource loaded: ${entry.name} in ${entry.duration}ms`);
            }
          });
        });
        
        observer.observe({ entryTypes: ['resource'] });
      }
    }

    sendToAnalytics(metric) {
      // Send performance metrics to analytics
      console.log('Performance metric:', metric);
      
      // Example: Send to Google Analytics
      if (typeof gtag !== 'undefined') {
        gtag('event', metric.name, {
          value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value),
          event_category: 'Web Vitals',
          event_label: metric.id,
          non_interaction: true,
        });
      }
    }

    notifyUpdate() {
      // Notify user of available update
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification('Update Available', {
          body: 'A new version of the site is available. Refresh to update.',
          icon: '/icons/icon-192x192.png'
        });
      }
    }

    // Public API for manual resource loading
    async loadResource(url, type = 'script') {
      if (type === 'script') {
        return this.loadScript(url);
      } else if (type === 'style') {
        return this.loadStylesheet(url);
      }
    }

    loadStylesheet(href) {
      if (this.loadedResources.has(href)) {
        return Promise.resolve();
      }

      return new Promise((resolve, reject) => {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = href;
        link.onload = () => {
          this.loadedResources.add(href);
          resolve();
        };
        link.onerror = reject;
        document.head.appendChild(link);
      });
    }
  }

  // Initialize Critical Resource Loader
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      window.criticalResourceLoader = new CriticalResourceLoader();
    });
  } else {
    window.criticalResourceLoader = new CriticalResourceLoader();
  }

  // Expose loader for external use
  window.loadResource = (url, type) => {
    return window.criticalResourceLoader?.loadResource(url, type);
  };
</script>

<style>
  /* Critical loading styles */
  .loading-indicator {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background: linear-gradient(90deg, 
      hsl(var(--primary, 220 100% 50%)) 0%, 
      hsl(var(--primary-light, 220 100% 70%)) 100%
    );
    transform: translateX(-100%);
    animation: loading-progress 2s ease-in-out infinite;
    z-index: 9999;
  }

  @keyframes loading-progress {
    0% {
      transform: translateX(-100%);
    }
    50% {
      transform: translateX(0%);
    }
    100% {
      transform: translateX(100%);
    }
  }

  /* Hide loading indicator when resources are loaded */
  .resources-loaded .loading-indicator {
    display: none;
  }

  /* Skeleton loading styles for content */
  .skeleton {
    background: linear-gradient(90deg, 
      hsl(var(--surface-muted, 0 0% 95%)) 25%, 
      hsl(var(--surface-secondary, 0 0% 90%)) 50%, 
      hsl(var(--surface-muted, 0 0% 95%)) 75%
    );
    background-size: 200% 100%;
    animation: skeleton-loading 1.5s infinite;
  }

  @keyframes skeleton-loading {
    0% {
      background-position: 200% 0;
    }
    100% {
      background-position: -200% 0;
    }
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .loading-indicator,
    .skeleton {
      animation: none;
    }
  }
</style>