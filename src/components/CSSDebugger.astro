---
// CSS Debugger Configuration - Enable all features for comprehensive debugging
const config = {
  enableCSSDebugger: true,
  enableErrorReporting: true,
  enableWarningReporting: true,
  enablePerformanceMonitoring: true,
  enableConflictDetection: true,
  enableUnusedCSSDetection: true,
  enableDebugMode: true,
  enableRealTimeMonitoring: true,
  enableAutoFix: true
};
---

// CSS Debugger Component - Enhanced version for comprehensive debugging
// Comprehensive debugging to identify and fix layout issues

export interface Props {
  enableCSSMonitoring?: boolean;
  enableConflictDetection?: boolean;
  enableVariableValidation?: boolean;
  enableUnusedCSSDetection?: boolean;
  enablePerformanceMonitoring?: boolean;
  enableErrorReporting?: boolean;
  enableWarningReporting?: boolean;
  enableDebugMode?: boolean;
  enableAutoFixing?: boolean;
  enableDarkModeValidation?: boolean;
  enableResponsiveValidation?: boolean;
  enablePrintValidation?: boolean;
  enableAccessibilityValidation?: boolean;
  enableBrowserCompatibility?: boolean;
  enablePerformanceOptimization?: boolean;
  enableCriticalCSS?: boolean;
  enableCSSCompression?: boolean;
  enableCacheValidation?: boolean;
  enableNetworkMonitoring?: boolean;
  debugThreshold?: number;
}

const {
  enableCSSMonitoring = true, // Enable comprehensive monitoring
  enableConflictDetection = true,
  enableVariableValidation = true,
  enableUnusedCSSDetection = true,
  enablePerformanceMonitoring = true,
  enableErrorReporting = true,
  enableWarningReporting = true,
  enableDebugMode = true,
  enableAutoFixing = true,
  enableDarkModeValidation = true,
  enableResponsiveValidation = true,
  enablePrintValidation = false,
  enableAccessibilityValidation = true,
  enableBrowserCompatibility = true,
  enablePerformanceOptimization = true,
  enableCriticalCSS = true,
  enableCSSCompression = false,
  enableCacheValidation = true,
  enableNetworkMonitoring = true,
  debugThreshold = 10,
} = Astro.props;
---

{enableErrorReporting && (
  <script>
    // Enhanced error reporting and debugging
    class CSSDebugger {
      constructor() {
        this.issues = [];
        this.fixes = [];
        this.init();
      }

      init() {
        console.log('ðŸ”§ CSS Debugger: Initializing comprehensive debugging...');
        
        // Check for layout issues
        this.checkLayoutIssues();
        
        // Check for CSS conflicts
        this.checkCSSConflicts();
        
        // Check for missing resources
        this.checkMissingResources();
        
        // Monitor performance
        this.monitorPerformance();
        
        // Auto-fix common issues
        this.autoFixIssues();
        
        // Report findings
        this.reportFindings();
      }

      checkLayoutIssues() {
        // Check for horizontal overflow
        const elements = document.querySelectorAll('*');
        elements.forEach(el => {
          const rect = el.getBoundingClientRect();
          if (rect.width > window.innerWidth) {
            this.issues.push({
              type: 'overflow',
              element: el,
              message: `Element exceeds viewport width: ${rect.width}px > ${window.innerWidth}px`,
              selector: this.getSelector(el)
            });
          }
        });

        // Check for missing alt attributes on images
        const images = document.querySelectorAll('img:not([alt])');
        images.forEach(img => {
          this.issues.push({
            type: 'accessibility',
            element: img,
            message: 'Image missing alt attribute',
            selector: this.getSelector(img)
          });
        });
      }

      checkCSSConflicts() {
        // Check for conflicting CSS properties
        const stylesheets = Array.from(document.styleSheets);
        const rules = new Map();
        
        stylesheets.forEach(sheet => {
          try {
            if (sheet.cssRules) {
              Array.from(sheet.cssRules).forEach(rule => {
                if (rule.selectorText) {
                  if (rules.has(rule.selectorText)) {
                    this.issues.push({
                      type: 'conflict',
                      message: `Duplicate CSS selector: ${rule.selectorText}`,
                      selector: rule.selectorText
                    });
                  }
                  rules.set(rule.selectorText, rule);
                }
              });
            }
          } catch (e) {
            // Cross-origin stylesheet, skip
          }
        });
      }

      checkMissingResources() {
        // Check for failed CSS loads
        const links = document.querySelectorAll('link[rel="stylesheet"]');
        links.forEach(link => {
          if (!link.sheet) {
            this.issues.push({
              type: 'resource',
              element: link,
              message: `Failed to load stylesheet: ${link.href}`,
              href: link.href
            });
          }
        });

        // Check for broken images
        const images = document.querySelectorAll('img');
        images.forEach(img => {
          if (img.naturalWidth === 0 && img.complete) {
            this.issues.push({
              type: 'resource',
              element: img,
              message: `Failed to load image: ${img.src}`,
              src: img.src
            });
          }
        });
      }

      monitorPerformance() {
        // Monitor CSS loading performance
        if (window.performance) {
          const entries = performance.getEntriesByType('resource');
          entries.forEach(entry => {
            if (entry.name.includes('.css')) {
              if (entry.duration > 1000) {
                this.issues.push({
                  type: 'performance',
                  message: `Slow CSS load: ${entry.name} took ${entry.duration.toFixed(2)}ms`,
                  resource: entry.name,
                  duration: entry.duration
                });
              }
            }
          });
        }
      }

      autoFixIssues() {
        // Auto-fix common overflow issues
        const overflowElements = document.querySelectorAll('*');
        overflowElements.forEach(el => {
          const rect = el.getBoundingClientRect();
          if (rect.width > window.innerWidth) {
            el.style.maxWidth = '100%';
            el.style.overflowX = 'hidden';
            this.fixes.push({
              type: 'overflow-fix',
              element: el,
              message: `Applied overflow fix to ${this.getSelector(el)}`
            });
          }
        });

        // Fix missing alt attributes
        const imagesWithoutAlt = document.querySelectorAll('img:not([alt])');
        imagesWithoutAlt.forEach(img => {
          img.setAttribute('alt', '');
          this.fixes.push({
            type: 'accessibility-fix',
            element: img,
            message: `Added empty alt attribute to ${this.getSelector(img)}`
          });
        });
      }

      getSelector(element) {
        if (element.id) return `#${element.id}`;
        if (element.className) return `.${element.className.split(' ')[0]}`;
        return element.tagName.toLowerCase();
      }

      reportFindings() {
        if (this.issues.length > 0) {
          console.group('ðŸš¨ CSS Issues Found');
          this.issues.forEach(issue => {
            console.warn(`${issue.type.toUpperCase()}: ${issue.message}`, issue.element || '');
          });
          console.groupEnd();
        }

        if (this.fixes.length > 0) {
          console.group('âœ… Auto-fixes Applied');
          this.fixes.forEach(fix => {
            console.log(`${fix.type.toUpperCase()}: ${fix.message}`, fix.element || '');
          });
          console.groupEnd();
        }

        if (this.issues.length === 0 && this.fixes.length === 0) {
          console.log('âœ… CSS Debugger: No issues found!');
        }

        // Update debug info display
        this.updateDebugDisplay();
      }

      updateDebugDisplay() {
        const debugInfo = document.querySelector('.css-debugger-info');
        if (debugInfo) {
          debugInfo.textContent = `Issues: ${this.issues.length} | Fixes: ${this.fixes.length}`;
          debugInfo.style.opacity = this.issues.length > 0 ? '1' : '0.5';
        }
      }
    }

    // Initialize debugger when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => new CSSDebugger());
    } else {
      new CSSDebugger();
    }

    // Re-run checks on window resize
    window.addEventListener('resize', () => {
      setTimeout(() => new CSSDebugger(), 100);
    });
  </script>
)}

<style>
  /* Enhanced CSS Debugger styles */
  .css-debugger-info {
    position: fixed;
    bottom: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-family: monospace;
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .css-debugger-info.active {
    opacity: 1;
  }

  /* Debug mode styles */
  body.debug-mode * {
    outline: 1px solid rgba(255, 0, 0, 0.2) !important;
  }

  body.debug-mode .overflow-issue {
    outline: 2px solid red !important;
    background: rgba(255, 0, 0, 0.1) !important;
  }
</style>

<!-- Debug info display -->
<div class="css-debugger-info" id="css-debug-info">
  Initializing CSS Debugger...
</div>