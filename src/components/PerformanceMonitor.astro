---
// Performance Monitor Component - Tracks and optimizes site performance
// Monitors Core Web Vitals, resource loading, and user experience metrics

export interface Props {
  enableAnalytics?: boolean;
  enableConsoleLogging?: boolean;
  enablePerformanceObserver?: boolean;
  enableResourceTiming?: boolean;
  enableNavigationTiming?: boolean;
  enableUserTiming?: boolean;
  enableLongTasks?: boolean;
  enableCLS?: boolean;
  enableLCP?: boolean;
  enableFID?: boolean;
  enableFCP?: boolean;
  enableTTFB?: boolean;
  enableMemoryMonitoring?: boolean;
  enableNetworkMonitoring?: boolean;
  reportingThreshold?: number;
}

const {
  enableAnalytics = true,
  enableConsoleLogging = true,
  enablePerformanceObserver = true,
  enableResourceTiming = true,
  enableNavigationTiming = true,
  enableUserTiming = true,
  enableLongTasks = true,
  enableCLS = true,
  enableLCP = true,
  enableFID = true,
  enableFCP = true,
  enableTTFB = true,
  enableMemoryMonitoring = true,
  enableNetworkMonitoring = true,
  reportingThreshold = 100, // ms
} = Astro.props;

// Performance monitoring configuration
const config = {
  enableAnalytics,
  enableConsoleLogging,
  enablePerformanceObserver,
  enableResourceTiming,
  enableNavigationTiming,
  enableUserTiming,
  enableLongTasks,
  enableCLS,
  enableLCP,
  enableFID,
  enableFCP,
  enableTTFB,
  enableMemoryMonitoring,
  enableNetworkMonitoring,
  reportingThreshold,
};
---

<script define:vars={{ config }}>
  class PerformanceMonitor {
    constructor(config) {
      this.config = config;
      this.metrics = {
        cls: 0,
        lcp: 0,
        fid: 0,
        fcp: 0,
        ttfb: 0,
        resources: [],
        longTasks: [],
        memory: {},
        navigation: {},
      };
      this.observers = {};
      this.startTime = performance.now();
      this.init();
    }
    
    init() {
      this.setupPerformanceObserver();
      this.setupResourceTiming();
      this.setupNavigationTiming();
      this.setupMemoryMonitoring();
      this.setupNetworkMonitoring();
      this.setupLongTaskMonitoring();
      this.setupUserTiming();
      this.setupCLSMonitoring();
      this.setupLCPMonitoring();
      this.setupFIDMonitoring();
      this.setupFCPMonitoring();
      this.setupTTFBMonitoring();
      
      // Report initial metrics after page load
      window.addEventListener('load', () => {
        setTimeout(() => {
          this.reportMetrics();
        }, 1000);
      });
      
      // Report metrics before page unload
      window.addEventListener('beforeunload', () => {
        this.reportMetrics();
      });
      
      // Periodic reporting
      setInterval(() => {
        this.reportMetrics();
      }, 30000); // Report every 30 seconds
    }
    
    setupPerformanceObserver() {
      if (!this.config.enablePerformanceObserver || !('PerformanceObserver' in window)) {
        return;
      }
      
      try {
        // Observe all performance entries
        this.observers.performance = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            this.processPerformanceEntry(entry);
          }
        });
        
        this.observers.performance.observe({ entryTypes: ['paint', 'measure', 'navigation'] });
        
        this.log('PerformanceObserver initialized');
      } catch (error) {
        this.error('Failed to setup PerformanceObserver:', error);
      }
    }
    
    setupResourceTiming() {
      if (!this.config.enableResourceTiming) {
        return;
      }
      
      try {
        // Monitor resource loading performance
        const resources = performance.getEntriesByType('resource');
        resources.forEach((resource) => {
          this.processResourceEntry(resource);
        });
        
        // Observe new resources
        if ('PerformanceObserver' in window) {
          this.observers.resources = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
              if (entry.entryType === 'resource') {
                this.processResourceEntry(entry);
              }
            }
          });
          
          this.observers.resources.observe({ entryTypes: ['resource'] });
        }
        
        this.log('Resource timing monitoring initialized');
      } catch (error) {
        this.error('Failed to setup resource timing:', error);
      }
    }
    
    setupNavigationTiming() {
      if (!this.config.enableNavigationTiming) {
        return;
      }
      
      try {
        const navigation = performance.getEntriesByType('navigation')[0];
        if (navigation) {
          this.metrics.navigation = {
            domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
            loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
            domInteractive: navigation.domInteractive,
            responseEnd: navigation.responseEnd,
            transferSize: navigation.transferSize,
            encodedBodySize: navigation.encodedBodySize,
            decodedBodySize: navigation.decodedBodySize,
          };
          
          this.metrics.ttfb = navigation.responseStart - navigation.requestStart;
        }
        
        this.log('Navigation timing monitoring initialized');
      } catch (error) {
        this.error('Failed to setup navigation timing:', error);
      }
    }
    
    setupMemoryMonitoring() {
      if (!this.config.enableMemoryMonitoring || !('memory' in performance)) {
        return;
      }
      
      try {
        // Monitor memory usage
        setInterval(() => {
          if (performance.memory) {
            this.metrics.memory = {
              usedJSHeapSize: performance.memory.usedJSHeapSize || 0,
              totalJSHeapSize: performance.memory.totalJSHeapSize || 0,
              jsHeapSizeLimit: performance.memory.jsHeapSizeLimit || 0,
              timestamp: Date.now(),
            };
            
            // Alert if memory usage is high
            if (performance.memory.usedJSHeapSize > performance.memory.jsHeapSizeLimit * 0.9) {
              this.warn('High memory usage detected:', this.metrics.memory);
            }
          } else {
            // Fallback for browsers that don't support performance.memory
            this.metrics.memory = {
              usedJSHeapSize: 0,
              totalJSHeapSize: 0,
              jsHeapSizeLimit: 0,
              timestamp: Date.now(),
            };
          }
        }, 5000);
        
        this.log('Memory monitoring initialized');
      } catch (error) {
        this.error('Failed to setup memory monitoring:', error);
      }
    }
    
    setupNetworkMonitoring() {
      if (!this.config.enableNetworkMonitoring || !('connection' in navigator)) {
        return;
      }
      
      try {
        const connection = navigator.connection;
        if (connection) {
          this.metrics.network = {
            effectiveType: connection.effectiveType,
            downlink: connection.downlink,
            rtt: connection.rtt,
            saveData: connection.saveData,
          };
          
          // Monitor network changes
          connection.addEventListener('change', () => {
            this.metrics.network = {
              effectiveType: connection.effectiveType,
              downlink: connection.downlink,
              rtt: connection.rtt,
              saveData: connection.saveData,
            };
            
            this.log('Network conditions changed:', this.metrics.network);
          });
        }
        
        this.log('Network monitoring initialized');
      } catch (error) {
        this.error('Failed to setup network monitoring:', error);
      }
    }
    
    setupLongTaskMonitoring() {
      if (!this.config.enableLongTasks || !('PerformanceObserver' in window)) {
        return;
      }
      
      try {
        this.observers.longTasks = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (entry.entryType === 'longtask') {
              this.metrics.longTasks.push({
                name: entry.name,
                duration: entry.duration,
                startTime: entry.startTime,
                attribution: entry.attribution,
              });
              
              // Alert if task is very long
              if (entry.duration > 200) {
                this.warn('Long task detected:', entry);
              }
            }
          }
        });
        
        this.observers.longTasks.observe({ entryTypes: ['longtask'] });
        
        this.log('Long task monitoring initialized');
      } catch (error) {
        this.error('Failed to setup long task monitoring:', error);
      }
    }
    
    setupUserTiming() {
      if (!this.config.enableUserTiming) {
        return;
      }
      
      try {
        // Create performance marks for user timing
        performance.mark('app-start');
        
        window.addEventListener('load', () => {
          performance.mark('app-loaded');
          performance.measure('app-load-time', 'app-start', 'app-loaded');
          
          const measure = performance.getEntriesByName('app-load-time')[0];
          if (measure) {
            this.log('App load time:', measure.duration);
          }
        });
        
        this.log('User timing initialized');
      } catch (error) {
        this.error('Failed to setup user timing:', error);
      }
    }
    
    setupCLSMonitoring() {
      if (!this.config.enableCLS || !('PerformanceObserver' in window)) {
        return;
      }
      
      try {
        let clsValue = 0;
        let clsEntries = [];
        
        this.observers.cls = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (!entry.hadRecentInput) {
              clsEntries.push(entry);
              clsValue += entry.value;
              
              this.metrics.cls = clsValue;
              
              this.log('CLS updated:', clsValue);
            }
          }
        });
        
        this.observers.cls.observe({ entryTypes: ['layout-shift'] });
        
        this.log('CLS monitoring initialized');
      } catch (error) {
        this.error('Failed to setup CLS monitoring:', error);
      }
    }
    
    setupLCPMonitoring() {
      if (!this.config.enableLCP || !('PerformanceObserver' in window)) {
        return;
      }
      
      try {
        this.observers.lcp = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const lastEntry = entries[entries.length - 1];
          
          this.metrics.lcp = lastEntry.startTime;
          
          this.log('LCP updated:', this.metrics.lcp);
        });
        
        this.observers.lcp.observe({ entryTypes: ['largest-contentful-paint'] });
        
        this.log('LCP monitoring initialized');
      } catch (error) {
        this.error('Failed to setup LCP monitoring:', error);
      }
    }
    
    setupFIDMonitoring() {
      if (!this.config.enableFID || !('PerformanceObserver' in window)) {
        return;
      }
      
      try {
        this.observers.fid = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (entry.entryType === 'first-input') {
              this.metrics.fid = entry.processingStart - entry.startTime;
              
              this.log('FID updated:', this.metrics.fid);
              
              // Disconnect after first input
              this.observers.fid.disconnect();
              break;
            }
          }
        });
        
        this.observers.fid.observe({ entryTypes: ['first-input'] });
        
        this.log('FID monitoring initialized');
      } catch (error) {
        this.error('Failed to setup FID monitoring:', error);
      }
    }
    
    setupFCPMonitoring() {
      if (!this.config.enableFCP || !('PerformanceObserver' in window)) {
        return;
      }
      
      try {
        this.observers.fcp = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (entry.name === 'first-contentful-paint') {
              this.metrics.fcp = entry.startTime;
              
              this.log('FCP updated:', this.metrics.fcp);
              
              // Disconnect after first contentful paint
              this.observers.fcp.disconnect();
              break;
            }
          }
        });
        
        this.observers.fcp.observe({ entryTypes: ['paint'] });
        
        this.log('FCP monitoring initialized');
      } catch (error) {
        this.error('Failed to setup FCP monitoring:', error);
      }
    }
    
    setupTTFBMonitoring() {
      if (!this.config.enableTTFB) {
        return;
      }
      
      try {
        const navigation = performance.getEntriesByType('navigation')[0];
        if (navigation) {
          this.metrics.ttfb = navigation.responseStart - navigation.requestStart;
        }
        
        this.log('TTFB monitoring initialized');
      } catch (error) {
        this.error('Failed to setup TTFB monitoring:', error);
      }
    }
    
    processPerformanceEntry(entry) {
      if (entry.entryType === 'measure') {
        this.log(`Performance measure: ${entry.name} - ${entry.duration}ms`);
      }
    }
    
    processResourceEntry(entry) {
      const resource = {
        name: entry.name,
        type: entry.initiatorType,
        duration: entry.duration,
        size: entry.transferSize,
        startTime: entry.startTime,
        responseEnd: entry.responseEnd,
      };
      
      this.metrics.resources.push(resource);
      
      // Smart threshold detection based on resource type and context
      const threshold = this.getResourceThreshold(entry);
      
      // Alert if resource is slow based on intelligent thresholds
      if (entry.duration > threshold) {
        this.warn(`Slow resource detected: ${entry.name} - ${entry.duration}ms (threshold: ${threshold}ms)`);
      }
    }
    
    getResourceThreshold(entry) {
      const url = entry.name;
      const type = entry.initiatorType;
      
      // Prefetch resources - more lenient threshold
      if (url.includes('prefetch') || 
          document.querySelector(`link[rel="prefetch"][href*="${url.split('/').pop()}"]`)) {
        return 500; // 500ms for prefetch resources
      }
      
      // Critical navigation resources - strict threshold
      if (type === 'navigation' || url === window.location.href) {
        return 100; // 100ms for critical navigation
      }
      
      // Images and media - moderate threshold
      if (type === 'img' || type === 'image' || 
          url.match(/\.(jpg|jpeg|png|gif|webp|svg|mp4|webm|ogg)$/i)) {
        return 200; // 200ms for images/media
      }
      
      // Scripts and stylesheets - moderate threshold
      if (type === 'script' || type === 'link' || 
          url.match(/\.(js|css)$/i)) {
        return 150; // 150ms for scripts/styles
      }
      
      // Fetch/XHR requests - moderate threshold
      if (type === 'fetch' || type === 'xmlhttprequest') {
        return 300; // 300ms for API calls
      }
      
      // Default threshold for other resources
      return this.config.reportingThreshold;
    }
    
    reportMetrics() {
      const report = {
        timestamp: Date.now(),
        url: window.location.href,
        userAgent: navigator.userAgent,
        metrics: this.metrics,
        sessionDuration: performance.now() - this.startTime,
      };
      
      // Console logging
      if (this.config.enableConsoleLogging) {
        console.group('Performance Report');
        console.log('Core Web Vitals:');
        console.log(`  CLS: ${this.metrics.cls.toFixed(4)}`);
        console.log(`  LCP: ${this.metrics.lcp.toFixed(0)}ms`);
        console.log(`  FID: ${this.metrics.fid.toFixed(0)}ms`);
        console.log(`  FCP: ${this.metrics.fcp.toFixed(0)}ms`);
        console.log(`  TTFB: ${this.metrics.ttfb.toFixed(0)}ms`);
        console.log('Resource Loading:');
        console.log(`  Total Resources: ${this.metrics.resources.length}`);
        console.log(`  Long Tasks: ${this.metrics.longTasks.length}`);
        console.log('Memory Usage:');
        const usedMB = this.metrics.memory.usedJSHeapSize ? (this.metrics.memory.usedJSHeapSize / 1024 / 1024).toFixed(2) : '0.00';
        const totalMB = this.metrics.memory.totalJSHeapSize ? (this.metrics.memory.totalJSHeapSize / 1024 / 1024).toFixed(2) : '0.00';
        console.log(`  Used: ${usedMB}MB`);
        console.log(`  Total: ${totalMB}MB`);
        console.groupEnd();
      }
      
      // Analytics reporting
      if (this.config.enableAnalytics && window.gtag) {
        window.gtag('event', 'performance_metrics', {
          cls: this.metrics.cls,
          lcp: this.metrics.lcp,
          fid: this.metrics.fid,
          fcp: this.metrics.fcp,
          ttfb: this.metrics.ttfb,
          resource_count: this.metrics.resources.length,
          long_task_count: this.metrics.longTasks.length,
          memory_used: this.metrics.memory.usedJSHeapSize,
        });
      }
      
      // Send to custom analytics endpoint
      if (window.analyticsEndpoint) {
        fetch(window.analyticsEndpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(report),
          keepalive: true, // Ensure the request completes even if the page is unloading
        }).catch((error) => {
          this.error('Failed to send performance report:', error);
        });
      }
      
      // Store in localStorage for debugging
      try {
        const reports = JSON.parse(localStorage.getItem('performanceReports') || '[]');
        reports.push(report);
        
        // Keep only last 100 reports
        if (reports.length > 100) {
          reports.splice(0, reports.length - 100);
        }
        
        localStorage.setItem('performanceReports', JSON.stringify(reports));
      } catch (error) {
        this.error('Failed to store performance report:', error);
      }
    }
    
    log(message, ...args) {
      if (this.config.enableConsoleLogging) {
        console.log(`[PerformanceMonitor] ${message}`, ...args);
      }
    }
    
    warn(message, ...args) {
      if (this.config.enableConsoleLogging) {
        console.warn(`[PerformanceMonitor] ${message}`, ...args);
      }
    }
    
    error(message, ...args) {
      if (this.config.enableConsoleLogging) {
        console.error(`[PerformanceMonitor] ${message}`, ...args);
      }
    }
    
    // Public API methods
    getMetrics() {
      return { ...this.metrics };
    }
    
    getCoreWebVitals() {
      return {
        cls: this.metrics.cls,
        lcp: this.metrics.lcp,
        fid: this.metrics.fid,
        fcp: this.metrics.fcp,
        ttfb: this.metrics.ttfb,
      };
    }
    
    resetMetrics() {
      this.metrics = {
        cls: 0,
        lcp: 0,
        fid: 0,
        fcp: 0,
        ttfb: 0,
        resources: [],
        longTasks: [],
        memory: {},
        navigation: {},
      };
    }
  }
  
  // Initialize performance monitor
  window.performanceMonitor = new PerformanceMonitor(config);
  
  // Expose global performance monitoring functions
  window.getPerformanceMetrics = () => window.performanceMonitor.getMetrics();
  window.getCoreWebVitals = () => window.performanceMonitor.getCoreWebVitals();
  window.resetPerformanceMetrics = () => window.performanceMonitor.resetMetrics();
  
  // Performance debugging helpers
  window.performanceDebug = {
    log: (message) => window.performanceMonitor.log(message),
    getSlowResources: (threshold = 1000) => {
      const metrics = window.performanceMonitor.getMetrics();
      return metrics.resources.filter(resource => resource.duration > threshold);
    },
    getMemoryUsage: () => {
      const metrics = window.performanceMonitor.getMetrics();
      return {
        used: metrics.memory.usedJSHeapSize,
        total: metrics.memory.totalJSHeapSize,
        percentage: (metrics.memory.usedJSHeapSize / metrics.memory.totalJSHeapSize) * 100,
      };
    },
    exportReport: () => {
      const reports = JSON.parse(localStorage.getItem('performanceReports') || '[]');
      const blob = new Blob([JSON.stringify(reports, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `performance-report-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    },
  };
  
  console.log('PerformanceMonitor initialized with config:', config);
</script>