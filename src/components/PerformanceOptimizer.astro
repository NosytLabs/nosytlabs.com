---
/**
 * Performance Optimizer Component
 * Implements critical CSS inlining and advanced performance optimizations
 * Removes duplicate font loading logic and focuses on layout/rendering performance
 */
---

<style is:inline>
/* ==========================================================================
   CRITICAL CSS - INLINED FOR IMMEDIATE RENDERING
   ========================================================================== */

/* Essential Design Tokens - Critical */
:root {
  --primary: 220 100% 50%;
  --primary-dark: 220 100% 45%;
  --text-primary: 220 20% 10%;
  --text-secondary: 220 10% 40%;
  --border-primary: 220 20% 90%;
  --background: 0 0% 100%;
}

/* Critical Layout & Container */
.container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 1rem;
  contain: layout style; /* CSS containment for better performance */
}

/* Critical Header - Fixed positioning with GPU acceleration */
.header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid hsl(var(--border-primary));
  transition: all 0.3s ease;
  contain: layout style;
  transform: translateZ(0); /* Force GPU acceleration */
}

.header-content {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 0;
  min-height: 4rem;
}

/* Critical Logo */
.logo {
  display: flex;
  align-items: center;
  font-size: 1.5rem;
  font-weight: 700;
  color: hsl(var(--text-primary));
  text-decoration: none;
  transition: color 0.3s ease;
}

/* Critical Navigation */
.nav {
  display: flex;
  align-items: center;
  gap: 2rem;
}

.nav-link {
  color: hsl(var(--text-secondary));
  text-decoration: none;
  font-weight: 500;
  transition: color 0.3s ease;
  position: relative;
}

/* Critical Hero Section with optimized rendering */
.hero {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 8rem 0 4rem;
  position: relative;
  contain: layout style;
  transform: translateZ(0); /* GPU acceleration */
}

.hero-content {
  max-width: 800px;
  margin: 0 auto;
  z-index: 2;
  position: relative;
}

.hero h1 {
  font-size: clamp(2.5rem, 5vw, 4rem);
  font-weight: 700;
  line-height: 1.1;
  margin-bottom: 1.5rem;
  color: hsl(var(--text-primary));
}

.hero p {
  font-size: clamp(1.1rem, 2vw, 1.25rem);
  line-height: 1.6;
  margin-bottom: 2rem;
  color: hsl(var(--text-secondary));
}

/* Critical Button with optimized animations */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.75rem 1.5rem;
  font-weight: 600;
  text-decoration: none;
  border-radius: 0.5rem;
  transition: all 0.3s ease;
  border: none;
  cursor: pointer;
  font-size: 1rem;
  line-height: 1.5;
  will-change: transform; /* Optimize for animations */
}

.btn-primary {
  background: hsl(var(--primary));
  color: white;
}

.btn-primary:hover {
  background: hsl(var(--primary-dark));
  transform: translateY(-2px);
}

/* Performance Optimizations */
.gpu-accelerated {
  transform: translateZ(0);
  backface-visibility: hidden;
  perspective: 1000px;
}

.will-change-transform {
  will-change: transform;
}

/* Optimized animations with reduced motion support */
@media (prefers-reduced-motion: reduce) {
  .btn-primary:hover {
    transform: none;
  }
  
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Critical Responsive with container queries support */
@media (min-width: 640px) {
  .container { padding: 0 1.5rem; }
}

@media (min-width: 1024px) {
  .container { padding: 0 2rem; }
}

@media (min-width: 1280px) {
  .container { max-width: 1280px; padding: 0 2.5rem; }
}

/* Image optimization classes */
.img-optimized {
  content-visibility: auto;
  contain-intrinsic-size: 300px 200px;
}

/* Layout optimization for major sections */
.section-optimized {
  contain: layout style;
  content-visibility: auto;
  contain-intrinsic-size: 0 500px;
}
</style>

<script is:inline>
/**
 * Advanced Performance Optimization Script
 * Implements performance monitoring, layout optimization, and resource management
 * Removed duplicate font loading logic (handled by FontPreloader)
 */

// Layout and Rendering Optimization
const optimizeLayout = () => {
  // Add CSS containment to major sections for better performance
  const sections = document.querySelectorAll('section, .hero, .services, .projects, .testimonials');
  sections.forEach(section => {
    section.style.contain = 'layout style';
    section.style.contentVisibility = 'auto';
  });
  
  // Optimize images with loading hints and intersection observer
  const images = document.querySelectorAll('img');
  images.forEach((img, index) => {
    // Critical images (above fold) - load immediately
    if (index < 3) {
      img.loading = 'eager';
      img.fetchPriority = 'high';
    } else {
      img.loading = 'lazy';
      img.fetchPriority = 'low';
    }
    
    // Add optimization classes
    img.classList.add('img-optimized');
  });
  
  // Optimize videos for performance
  const videos = document.querySelectorAll('video');
  videos.forEach(video => {
    video.preload = 'metadata';
    video.loading = 'lazy';
  });
};

// Advanced Performance Monitoring
const monitorPerformance = () => {
  if ('performance' in window) {
    window.addEventListener('load', () => {
      // Use requestIdleCallback for non-critical performance monitoring
      const schedulePerformanceCheck = window.requestIdleCallback || ((cb) => setTimeout(cb, 1));
      
      schedulePerformanceCheck(() => {
        try {
          const perfData = performance.getEntriesByType('navigation')[0];
          const lcp = performance.getEntriesByType('largest-contentful-paint')[0];
          const cls = performance.getEntriesByType('layout-shift');
          
          // Calculate CLS score
          let clsScore = 0;
          cls.forEach(entry => {
            if (!entry.hadRecentInput) {
              clsScore += entry.value;
            }
          });
          
          const metrics = {
            domContentLoaded: Math.round(perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart),
            loadComplete: Math.round(perfData.loadEventEnd - perfData.loadEventStart),
            lcp: lcp ? Math.round(lcp.startTime) : 'Not available',
            cls: Math.round(clsScore * 1000) / 1000,
            ttfb: Math.round(perfData.responseStart - perfData.requestStart)
          };
          
          // Only log in development
          if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log('ðŸš€ Performance Metrics:', metrics);
          }
          
          // Dispatch performance event for other components
          document.dispatchEvent(new CustomEvent('performanceMetrics', { detail: metrics }));
        } catch (error) {
          console.warn('Performance monitoring error:', error);
        }
      });
    });
  }
};

// Resource Optimization
const optimizeResources = () => {
  // Preload critical resources
  const criticalResources = [
    { href: '/fonts/inter-latin.woff2', as: 'font', type: 'font/woff2' }
  ];
  
  criticalResources.forEach(resource => {
    const existingLink = document.querySelector(`link[href="${resource.href}"]`);
    if (!existingLink) {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.href = resource.href;
      link.as = resource.as;
      if (resource.type) link.type = resource.type;
      if (resource.as === 'font') link.crossOrigin = 'anonymous';
      document.head.appendChild(link);
    }
  });
};

// Service Worker Registration (for production caching)
const registerServiceWorker = () => {
  if ('serviceWorker' in navigator && window.location.protocol === 'https:') {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js')
        .then(registration => {
          console.log('SW registered: ', registration);
        })
        .catch(registrationError => {
          console.log('SW registration failed: ', registrationError);
        });
    });
  }
};

// Initialize all optimizations
document.addEventListener('DOMContentLoaded', () => {
  optimizeLayout();
  optimizeResources();
  monitorPerformance();
  
  // Register service worker only in production
  if (window.location.protocol === 'https:') {
    registerServiceWorker();
  }
});

// Optimize for page visibility changes
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Page is hidden - pause non-critical operations
    document.dispatchEvent(new CustomEvent('pageHidden'));
  } else {
    // Page is visible - resume operations
    document.dispatchEvent(new CustomEvent('pageVisible'));
  }
});
</script>

---
// Performance Optimizer Component - Enhanced version for comprehensive performance optimization
// Automatically detects and fixes performance issues

export interface Props {
  enableImageOptimization?: boolean;
  enableCSSOptimization?: boolean;
  enableJSOptimization?: boolean;
  enableLazyLoading?: boolean;
  enableCaching?: boolean;
  enablePreloading?: boolean;
  enableMinification?: boolean;
  enableCompression?: boolean;
  enableCriticalCSS?: boolean;
  enableResourceHints?: boolean;
  debugMode?: boolean;
}

const {
  enableImageOptimization = true,
  enableCSSOptimization = true,
  enableJSOptimization = true,
  enableLazyLoading = true,
  enableCaching = true,
  enablePreloading = true,
  enableMinification = true,
  enableCompression = true,
  enableCriticalCSS = true,
  enableResourceHints = true,
  debugMode = false,
} = Astro.props;
---

<script>
  class PerformanceOptimizer {
    constructor() {
      this.config = {
        enableImageOptimization: true,
        enableCSSOptimization: true,
        enableJSOptimization: true,
        enableLazyLoading: true,
        enableCaching: true,
        enablePreloading: true,
        enableMinification: true,
        enableCompression: true,
        enableCriticalCSS: true,
        enableResourceHints: true,
        debugMode: false,
      };
      
      this.metrics = {
        loadTime: 0,
        domContentLoaded: 0,
        firstContentfulPaint: 0,
        largestContentfulPaint: 0,
        cumulativeLayoutShift: 0,
        firstInputDelay: 0,
        totalBlockingTime: 0,
      };
      
      this.optimizations = [];
      this.resourcesOptimized = 0;
      this.bytesOptimized = 0;
      
      this.init();
    }

    init() {
      console.log('ðŸš€ Performance Optimizer: Starting comprehensive performance optimization...');
      
      // Wait for DOM to be ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => this.runOptimizations());
      } else {
        this.runOptimizations();
      }
      
      // Monitor performance metrics
      this.setupPerformanceMonitoring();
    }

    runOptimizations() {
      // Run all optimizations
      if (this.config.enableImageOptimization) this.optimizeImages();
      if (this.config.enableCSSOptimization) this.optimizeCSS();
      if (this.config.enableJSOptimization) this.optimizeJavaScript();
      if (this.config.enableLazyLoading) this.implementLazyLoading();
      if (this.config.enableCaching) this.optimizeCaching();
      if (this.config.enablePreloading) this.implementPreloading();
      if (this.config.enableResourceHints) this.addResourceHints();
      if (this.config.enableCriticalCSS) this.optimizeCriticalCSS();
      
      // Report results
      setTimeout(() => this.reportOptimizations(), 1000);
    }

    setupPerformanceMonitoring() {
      // Monitor Core Web Vitals
      if ('PerformanceObserver' in window) {
        // Largest Contentful Paint
        new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          const lastEntry = entries[entries.length - 1];
          this.metrics.largestContentfulPaint = lastEntry.startTime;
        }).observe({ entryTypes: ['largest-contentful-paint'] });

        // First Input Delay
        new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          entries.forEach((entry) => {
            this.metrics.firstInputDelay = entry.processingStart - entry.startTime;
          });
        }).observe({ entryTypes: ['first-input'] });

        // Cumulative Layout Shift
        new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          entries.forEach((entry) => {
            if (!entry.hadRecentInput) {
              this.metrics.cumulativeLayoutShift += entry.value;
            }
          });
        }).observe({ entryTypes: ['layout-shift'] });
      }

      // Monitor load times
      window.addEventListener('load', () => {
        const navigation = performance.getEntriesByType('navigation')[0];
        this.metrics.loadTime = navigation.loadEventEnd - navigation.fetchStart;
        this.metrics.domContentLoaded = navigation.domContentLoadedEventEnd - navigation.fetchStart;
        
        // Get First Contentful Paint
        const paintEntries = performance.getEntriesByType('paint');
        const fcpEntry = paintEntries.find(entry => entry.name === 'first-contentful-paint');
        if (fcpEntry) {
          this.metrics.firstContentfulPaint = fcpEntry.startTime;
        }
      });
    }

    optimizeImages() {
      const images = document.querySelectorAll('img');
      let optimized = 0;
      
      images.forEach((img) => {
        // Add loading="lazy" if not present
        if (!img.hasAttribute('loading')) {
          img.setAttribute('loading', 'lazy');
          optimized++;
        }
        
        // Add decoding="async" for better performance
        if (!img.hasAttribute('decoding')) {
          img.setAttribute('decoding', 'async');
          optimized++;
        }
        
        // Optimize image dimensions
        if (!img.hasAttribute('width') || !img.hasAttribute('height')) {
          img.onload = () => {
            if (!img.hasAttribute('width')) img.setAttribute('width', img.naturalWidth);
            if (!img.hasAttribute('height')) img.setAttribute('height', img.naturalHeight);
          };
          optimized++;
        }
        
        // Add responsive image handling
        if (!img.hasAttribute('sizes') && img.hasAttribute('srcset')) {
          img.setAttribute('sizes', '(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw');
          optimized++;
        }
      });
      
      if (optimized > 0) {
        this.optimizations.push({
          type: 'image-optimization',
          count: optimized,
          message: `Optimized ${optimized} images with lazy loading and async decoding`
        });
        this.resourcesOptimized += optimized;
      }
    }

    optimizeCSS() {
      const stylesheets = document.querySelectorAll('link[rel="stylesheet"]');
      let optimized = 0;
      
      stylesheets.forEach((link) => {
        // Add media attribute if not present
        if (!link.hasAttribute('media')) {
          link.setAttribute('media', 'all');
          optimized++;
        }
        
        // Preload critical CSS
        if (link.href.includes('critical') || link.href.includes('above-fold')) {
          link.setAttribute('rel', 'preload');
          link.setAttribute('as', 'style');
          link.setAttribute('onload', "this.onload=null;this.rel='stylesheet'");
          optimized++;
        }
      });
      
      // Remove unused CSS classes (basic implementation)
      this.removeUnusedCSS();
      
      if (optimized > 0) {
        this.optimizations.push({
          type: 'css-optimization',
          count: optimized,
          message: `Optimized ${optimized} CSS resources with preloading and media queries`
        });
        this.resourcesOptimized += optimized;
      }
    }

    removeUnusedCSS() {
      // Get all CSS rules
      const usedClasses = new Set();
      const allElements = document.querySelectorAll('*');
      
      // Collect all used classes
      allElements.forEach((element) => {
        if (element.className) {
          const classes = element.className.split(' ');
          classes.forEach((cls) => {
            if (cls.trim()) usedClasses.add(cls.trim());
          });
        }
      });
      
      // This is a simplified version - in production, you'd want a more sophisticated approach
      console.log(`ðŸŽ¯ Found ${usedClasses.size} CSS classes in use`);
    }

    optimizeJavaScript() {
      const scripts = document.querySelectorAll('script[src]');
      let optimized = 0;
      
      scripts.forEach((script) => {
        // Add async or defer if not present
        if (!script.hasAttribute('async') && !script.hasAttribute('defer')) {
          // Use defer for scripts that don't need to run immediately
          if (!script.src.includes('critical') && !script.src.includes('inline')) {
            script.setAttribute('defer', '');
            optimized++;
          }
        }
        
        // Add crossorigin for external scripts
        if (script.src.includes('http') && !script.hasAttribute('crossorigin')) {
          script.setAttribute('crossorigin', 'anonymous');
          optimized++;
        }
      });
      
      if (optimized > 0) {
        this.optimizations.push({
          type: 'js-optimization',
          count: optimized,
          message: `Optimized ${optimized} JavaScript resources with async/defer loading`
        });
        this.resourcesOptimized += optimized;
      }
    }

    implementLazyLoading() {
      // Lazy load iframes
      const iframes = document.querySelectorAll('iframe');
      let optimized = 0;
      
      iframes.forEach((iframe) => {
        if (!iframe.hasAttribute('loading')) {
          iframe.setAttribute('loading', 'lazy');
          optimized++;
        }
      });
      
      // Lazy load background images
      const elementsWithBgImages = document.querySelectorAll('[style*="background-image"]');
      elementsWithBgImages.forEach((element) => {
        if (!element.classList.contains('lazy-bg')) {
          element.classList.add('lazy-bg');
          optimized++;
        }
      });
      
      if (optimized > 0) {
        this.optimizations.push({
          type: 'lazy-loading',
          count: optimized,
          message: `Implemented lazy loading for ${optimized} resources`
        });
        this.resourcesOptimized += optimized;
      }
    }

    optimizeCaching() {
      // Add cache-busting for static resources
      const staticResources = document.querySelectorAll('link[href], script[src], img[src]');
      let optimized = 0;
      
      staticResources.forEach((resource) => {
        const url = resource.href || resource.src;
        if (url && !url.includes('?') && !url.includes('#')) {
          // Add version parameter for cache busting
          const separator = url.includes('?') ? '&' : '?';
          const newUrl = `${url}${separator}v=${Date.now()}`;
          
          if (resource.href) resource.href = newUrl;
          if (resource.src) resource.src = newUrl;
          
          optimized++;
        }
      });
      
      // Set up service worker for caching (if not already present)
      if ('serviceWorker' in navigator && !navigator.serviceWorker.controller) {
        navigator.serviceWorker.register('/service-worker.js').catch(() => {
          console.log('Service worker registration failed');
        });
      }
      
      if (optimized > 0) {
        this.optimizations.push({
          type: 'caching-optimization',
          count: optimized,
          message: `Optimized caching for ${optimized} static resources`
        });
      }
    }

    implementPreloading() {
      // Preload critical resources
      const criticalResources = [
        { href: '/fonts/inter.woff2', as: 'font', type: 'font/woff2' },
        { href: '/styles/critical.css', as: 'style' },
        { href: '/images/hero-bg.webp', as: 'image' },
      ];
      
      let preloaded = 0;
      
      criticalResources.forEach((resource) => {
        // Check if preload link already exists
        const existingPreload = document.querySelector(`link[rel="preload"][href="${resource.href}"]`);
        
        if (!existingPreload) {
          const link = document.createElement('link');
          link.rel = 'preload';
          link.href = resource.href;
          link.as = resource.as;
          if (resource.type) link.type = resource.type;
          if (resource.as === 'font') link.crossOrigin = 'anonymous';
          
          document.head.appendChild(link);
          preloaded++;
        }
      });
      
      // Preload next page resources based on user behavior
      this.setupIntelligentPreloading();
      
      if (preloaded > 0) {
        this.optimizations.push({
          type: 'preloading',
          count: preloaded,
          message: `Preloaded ${preloaded} critical resources`
        });
      }
    }

    setupIntelligentPreloading() {
      // Preload resources when user hovers over links
      const links = document.querySelectorAll('a[href^="/"], a[href^="./"]');
      
      links.forEach((link) => {
        link.addEventListener('mouseenter', () => {
          const href = link.getAttribute('href');
          if (href && !document.querySelector(`link[rel="prefetch"][href="${href}"]`)) {
            const prefetchLink = document.createElement('link');
            prefetchLink.rel = 'prefetch';
            prefetchLink.href = href;
            document.head.appendChild(prefetchLink);
          }
        }, { once: true });
      });
    }

    addResourceHints() {
      // Add DNS prefetch for external domains
      const externalDomains = new Set();
      const externalResources = document.querySelectorAll('link[href*="//"], script[src*="//"], img[src*="//"]');
      
      externalResources.forEach((resource) => {
        const url = resource.href || resource.src;
        if (url) {
          try {
            const domain = new URL(url).hostname;
            if (domain !== window.location.hostname) {
              externalDomains.add(domain);
            }
          } catch (e) {
            // Invalid URL, skip
          }
        }
      });
      
      let hintsAdded = 0;
      
      externalDomains.forEach((domain) => {
        // Check if DNS prefetch already exists
        if (!document.querySelector(`link[rel="dns-prefetch"][href="//${domain}"]`)) {
          const link = document.createElement('link');
          link.rel = 'dns-prefetch';
          link.href = `//${domain}`;
          document.head.appendChild(link);
          hintsAdded++;
        }
      });
      
      if (hintsAdded > 0) {
        this.optimizations.push({
          type: 'resource-hints',
          count: hintsAdded,
          message: `Added DNS prefetch for ${hintsAdded} external domains`
        });
      }
    }

    optimizeCriticalCSS() {
      // Identify above-the-fold content
      const viewportHeight = window.innerHeight;
      const criticalElements = [];
      
      document.querySelectorAll('*').forEach((element) => {
        const rect = element.getBoundingClientRect();
        if (rect.top < viewportHeight && rect.bottom > 0) {
          criticalElements.push(element);
        }
      });
      
      // This is a simplified version - in production, you'd extract actual CSS rules
      console.log(`ðŸŽ¯ Identified ${criticalElements.length} critical elements above the fold`);
      
      this.optimizations.push({
        type: 'critical-css',
        count: criticalElements.length,
        message: `Identified ${criticalElements.length} critical elements for CSS optimization`
      });
    }

    measurePerformance() {
      const metrics = {
        // Core Web Vitals
        lcp: this.metrics.largestContentfulPaint,
        fid: this.metrics.firstInputDelay,
        cls: this.metrics.cumulativeLayoutShift,
        
        // Other metrics
        fcp: this.metrics.firstContentfulPaint,
        loadTime: this.metrics.loadTime,
        domContentLoaded: this.metrics.domContentLoaded,
        
        // Resource metrics
        resourcesOptimized: this.resourcesOptimized,
        optimizationsApplied: this.optimizations.length,
      };
      
      return metrics;
    }

    getPerformanceScore() {
      const metrics = this.measurePerformance();
      let score = 100;
      
      // Deduct points based on Core Web Vitals
      if (metrics.lcp > 2500) score -= 20;
      else if (metrics.lcp > 1200) score -= 10;
      
      if (metrics.fid > 100) score -= 20;
      else if (metrics.fid > 50) score -= 10;
      
      if (metrics.cls > 0.25) score -= 20;
      else if (metrics.cls > 0.1) score -= 10;
      
      // Deduct points for slow load times
      if (metrics.loadTime > 3000) score -= 15;
      else if (metrics.loadTime > 1500) score -= 8;
      
      return Math.max(0, score);
    }

    reportOptimizations() {
      const metrics = this.measurePerformance();
      const score = this.getPerformanceScore();
      
      console.group('ðŸš€ Performance Optimization Results');
      
      console.log(`Performance Score: ${score}/100`);
      console.log(`Resources Optimized: ${this.resourcesOptimized}`);
      console.log(`Optimizations Applied: ${this.optimizations.length}`);
      
      if (this.optimizations.length > 0) {
        console.group('Applied Optimizations');
        this.optimizations.forEach((opt) => {
          console.log(`âœ… ${opt.message}`);
        });
        console.groupEnd();
      }
      
      console.group('Performance Metrics');
      console.log(`Load Time: ${metrics.loadTime.toFixed(0)}ms`);
      console.log(`DOM Content Loaded: ${metrics.domContentLoaded.toFixed(0)}ms`);
      console.log(`First Contentful Paint: ${metrics.fcp.toFixed(0)}ms`);
      console.log(`Largest Contentful Paint: ${metrics.lcp.toFixed(0)}ms`);
      console.log(`First Input Delay: ${metrics.fid.toFixed(0)}ms`);
      console.log(`Cumulative Layout Shift: ${metrics.cls.toFixed(3)}`);
      console.groupEnd();
      
      console.groupEnd();
      
      // Update status display
      this.updateStatusDisplay(score, this.optimizations.length);
    }

    updateStatusDisplay(score, optimizations) {
      // Create or update status display
      let statusEl = document.querySelector('.performance-optimizer-status');
      if (!statusEl) {
        statusEl = document.createElement('div');
        statusEl.className = 'performance-optimizer-status';
        document.body.appendChild(statusEl);
      }
      
      statusEl.textContent = `Performance: ${score}/100 (${optimizations} optimizations)`;
      statusEl.style.opacity = '1';
      
      // Color code based on score
      if (score >= 90) {
        statusEl.style.background = 'rgba(0, 150, 0, 0.9)';
      } else if (score >= 70) {
        statusEl.style.background = 'rgba(255, 165, 0, 0.9)';
      } else {
        statusEl.style.background = 'rgba(255, 0, 0, 0.9)';
      }
    }
  }

  // Initialize Performance Optimizer
  new PerformanceOptimizer();

  // Re-run optimizations on page visibility change
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      setTimeout(() => new PerformanceOptimizer(), 100);
    }
  });
</script>

<style>
  .performance-optimizer-status {
    position: fixed;
    bottom: 90px;
    right: 10px;
    background: rgba(0, 150, 0, 0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-family: monospace;
    z-index: 9999;
    opacity: 0;
    transition: all 0.3s ease;
    pointer-events: none;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .performance-optimizer-status.active {
    opacity: 1;
  }

  /* Lazy loading styles */
  .lazy-bg {
    background-image: none !important;
    transition: background-image 0.3s ease;
  }

  .lazy-bg.loaded {
    background-image: var(--bg-image) !important;
  }

  /* Performance indicators */
  .performance-optimized {
    position: relative;
  }

  .performance-optimized::after {
    content: 'âš¡';
    position: absolute;
    top: -5px;
    right: -5px;
    font-size: 12px;
    opacity: 0.7;
  }
</style>