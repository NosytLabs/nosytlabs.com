---
/**
 * Enhanced Interactive Particle System for Hero Section
 * Features: AI-themed particles, neural connections, and quantum effects
 */

export interface Props {
  particleCount?: number;
  connectionDistance?: number;
  particleSpeed?: number;
  showConnections?: boolean;
  interactive?: boolean;
  theme?: 'ai' | 'quantum' | 'neural' | 'data';
  intensity?: 'low' | 'medium' | 'high';
}

const {
  particleCount = 80,
  connectionDistance = 150,
  particleSpeed = 0.5,
  showConnections = true,
  interactive = true,
  theme = 'ai',
  intensity = 'medium',
} = Astro.props;

const intensitySettings = {
  low: { particles: Math.floor(particleCount * 0.6), opacity: 0.3 },
  medium: { particles: particleCount, opacity: 0.5 },
  high: { particles: Math.floor(particleCount * 1.4), opacity: 0.7 },
};

const currentSettings = intensitySettings[intensity];
---

<div 
  id="particle-system" 
  class="absolute inset-0 overflow-hidden pointer-events-none"
  data-particle-count={currentSettings.particles}
  data-connection-distance={connectionDistance}
  data-particle-speed={particleSpeed}
  data-show-connections={showConnections}
  data-interactive={interactive}
  data-theme={theme}
  data-opacity={currentSettings.opacity}
>
  <!-- Canvas for particle rendering -->
  <canvas 
    id="particle-canvas" 
    class="absolute inset-0 w-full h-full"
    style={`opacity: ${currentSettings.opacity}`}
  ></canvas>

  <!-- Static particle fallback for non-JS environments -->
  <noscript>
    <div class="absolute inset-0">
      {Array.from({ length: 20 }, (_, i) => (
        <div
          key={i}
          class="absolute w-1 h-1 bg-primary rounded-full animate-pulse"
          style={`
            left: ${Math.random() * 100}%;
            top: ${Math.random() * 100}%;
            animation-delay: ${Math.random() * 3}s;
          `}
        ></div>
      ))}
    </div>
  </noscript>
</div>

<!-- Particle System Styles -->
<style>
  #particle-canvas {
    mix-blend-mode: screen;
  }

  @media (prefers-reduced-motion: reduce) {
    #particle-system {
      display: none;
    }
  }
</style>

<!-- Enhanced Particle System Script -->
<script>
  interface Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    size: number;
    color: string;
    alpha: number;
    life: number;
    maxLife: number;
    type: 'node' | 'data' | 'quantum' | 'neural';
  }

  interface Connection {
    particle1: Particle;
    particle2: Particle;
    strength: number;
  }

  class EnhancedParticleSystem {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private particles: Particle[] = [];
    private connections: Connection[] = [];
    private mouse = { x: 0, y: 0, radius: 100 };
    private animationId: number = 0;
    private config: any;

    constructor(canvas: HTMLCanvasElement, config: any) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d')!;
      this.config = config;
      
      this.setupCanvas();
      this.createParticles();
      this.bindEvents();
      this.animate();
    }

    private setupCanvas(): void {
      const updateCanvasSize = () => {
        const rect = this.canvas.getBoundingClientRect();
        this.canvas.width = rect.width * window.devicePixelRatio;
        this.canvas.height = rect.height * window.devicePixelRatio;
        this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
      };

      updateCanvasSize();
      window.addEventListener('resize', updateCanvasSize);
    }

    private createParticles(): void {
      const colors = this.getThemeColors();
      const types = this.getParticleTypes();

      for (let i = 0; i < this.config.particleCount; i++) {
        const particle: Particle = {
          x: Math.random() * this.canvas.clientWidth,
          y: Math.random() * this.canvas.clientHeight,
          vx: (Math.random() - 0.5) * this.config.particleSpeed,
          vy: (Math.random() - 0.5) * this.config.particleSpeed,
          size: Math.random() * 3 + 1,
          color: colors[Math.floor(Math.random() * colors.length)],
          alpha: Math.random() * 0.8 + 0.2,
          life: Math.random() * 100,
          maxLife: 100 + Math.random() * 100,
          type: types[Math.floor(Math.random() * types.length)]
        };
        this.particles.push(particle);
      }
    }

    // Resolve CSS variable colors (e.g., "var(--color-primary-500)") to concrete color values for Canvas
    private resolveColor(color: string): string {
      try {
        if (typeof color === 'string' && color.startsWith('var(')) {
          const inside = color.substring(color.indexOf('(') + 1, color.lastIndexOf(')'));
          const varName = inside.split(',')[0].trim();
          const value = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
          // Fallback to a safe color if variable not found
          return value || 'var(--color-primary-500)';
        }
        return color;
      } catch {
        return 'var(--color-primary-500)';
      }
    }

    private getThemeColors(): string[] {
      const themes = {
        ai: ['var(--color-primary-500)', 'var(--color-secondary-500)', 'var(--color-accent-500)', 'var(--color-success-500)'],
        quantum: ['var(--color-warning-500)', 'var(--color-error-500)', 'var(--color-secondary-500)', 'var(--color-accent-500)'],
        neural: ['var(--color-success-500)', 'var(--color-primary-500)', 'var(--color-warning-500)', 'var(--color-error-500)'],
        data: ['var(--color-accent-500)', 'var(--color-secondary-500)', 'var(--color-success-500)', 'var(--color-warning-500)']
      } as const;

      const selected = themes[this.config.theme as keyof typeof themes] || themes.ai;
      // Map CSS variables to computed color strings so Canvas can use them
      return selected.map((c) => this.resolveColor(c));
    }

    private getParticleTypes(): ('node' | 'data' | 'quantum' | 'neural')[] {
      const typeMap = {
        ai: ['node', 'data', 'neural'],
        quantum: ['quantum', 'node'],
        neural: ['neural', 'node'],
        data: ['data', 'node']
      };
      return typeMap[this.config.theme as keyof typeof typeMap] || typeMap.ai;
    }

    private bindEvents(): void {
      if (this.config.interactive) {
        this.canvas.addEventListener('mousemove', (e) => {
          const rect = this.canvas.getBoundingClientRect();
          this.mouse.x = e.clientX - rect.left;
          this.mouse.y = e.clientY - rect.top;
        });

        this.canvas.addEventListener('mouseleave', () => {
          this.mouse.x = -1000;
          this.mouse.y = -1000;
        });
      }
    }

    private updateParticles(): void {
      this.particles.forEach((particle, index) => {
        // Update position
        particle.x += particle.vx;
        particle.y += particle.vy;

        // Update life
        particle.life += 1;
        if (particle.life > particle.maxLife) {
          particle.life = 0;
          particle.alpha = Math.random() * 0.8 + 0.2;
        }

        // Boundary collision
        if (particle.x < 0 || particle.x > this.canvas.clientWidth) {
          particle.vx *= -1;
        }
        if (particle.y < 0 || particle.y > this.canvas.clientHeight) {
          particle.vy *= -1;
        }

        // Mouse interaction
        if (this.config.interactive) {
          const dx = this.mouse.x - particle.x;
          const dy = this.mouse.y - particle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < this.mouse.radius) {
            const force = (this.mouse.radius - distance) / this.mouse.radius;
            const angle = Math.atan2(dy, dx);
            particle.vx -= Math.cos(angle) * force * 0.5;
            particle.vy -= Math.sin(angle) * force * 0.5;
          }
        }

        // Apply friction
        particle.vx *= 0.99;
        particle.vy *= 0.99;

        // Add some randomness
        particle.vx += (Math.random() - 0.5) * 0.01;
        particle.vy += (Math.random() - 0.5) * 0.01;
      });
    }

    private updateConnections(): void {
      if (!this.config.showConnections) return;

      this.connections = [];
      
      for (let i = 0; i < this.particles.length; i++) {
        for (let j = i + 1; j < this.particles.length; j++) {
          const particle1 = this.particles[i];
          const particle2 = this.particles[j];
          
          const dx = particle1.x - particle2.x;
          const dy = particle1.y - particle2.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < this.config.connectionDistance) {
            const strength = 1 - (distance / this.config.connectionDistance);
            this.connections.push({ particle1, particle2, strength });
          }
        }
      }
    }

    private drawParticle(particle: Particle): void {
      this.ctx.save();
      this.ctx.globalAlpha = particle.alpha;
      this.ctx.fillStyle = particle.color;

      switch (particle.type) {
        case 'node':
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          this.ctx.fill();
          
          // Add glow effect
          this.ctx.shadowColor = particle.color;
          this.ctx.shadowBlur = particle.size * 2;
          this.ctx.fill();
          break;

        case 'data':
          this.ctx.fillRect(
            particle.x - particle.size / 2,
            particle.y - particle.size / 2,
            particle.size,
            particle.size
          );
          break;

        case 'quantum':
          this.ctx.save();
          this.ctx.translate(particle.x, particle.y);
          this.ctx.rotate(particle.life * 0.1);
          this.ctx.fillRect(-particle.size / 2, -particle.size / 2, particle.size, particle.size);
          this.ctx.restore();
          break;

        case 'neural':
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.size * 0.5, 0, Math.PI * 2);
          this.ctx.fill();
          
          // Neural spikes
          for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const x1 = particle.x + Math.cos(angle) * particle.size * 0.5;
            const y1 = particle.y + Math.sin(angle) * particle.size * 0.5;
            const x2 = particle.x + Math.cos(angle) * particle.size * 1.5;
            const y2 = particle.y + Math.sin(angle) * particle.size * 1.5;
            
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.strokeStyle = particle.color;
            this.ctx.lineWidth = 1;
            this.ctx.stroke();
          }
          break;
      }

      this.ctx.restore();
    }

    private drawConnection(connection: Connection): void {
      this.ctx.save();
      this.ctx.globalAlpha = connection.strength * 0.3;
      this.ctx.strokeStyle = connection.particle1.color;
      this.ctx.lineWidth = connection.strength * 2;
      
      // Create gradient line
      const gradient = this.ctx.createLinearGradient(
        connection.particle1.x, connection.particle1.y,
        connection.particle2.x, connection.particle2.y
      );
      gradient.addColorStop(0, connection.particle1.color);
      gradient.addColorStop(1, connection.particle2.color);
      this.ctx.strokeStyle = gradient;

      this.ctx.beginPath();
      this.ctx.moveTo(connection.particle1.x, connection.particle1.y);
      this.ctx.lineTo(connection.particle2.x, connection.particle2.y);
      this.ctx.stroke();
      
      this.ctx.restore();
    }

    private render(): void {
      // Clear canvas
      this.ctx.clearRect(0, 0, this.canvas.clientWidth, this.canvas.clientHeight);

      // Draw connections first (behind particles)
      this.connections.forEach(connection => this.drawConnection(connection));

      // Draw particles
      this.particles.forEach(particle => this.drawParticle(particle));
    }

    private animate(): void {
      this.updateParticles();
      this.updateConnections();
      this.render();
      
      this.animationId = requestAnimationFrame(() => this.animate());
    }

    public destroy(): void {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }

  // Initialize particle system
  function initParticleSystem() {
    // Skip initialization during server-side rendering
    if (typeof window === 'undefined' || typeof document === 'undefined') return;
    
    const container = document.getElementById('particle-system');
    const canvas = document.getElementById('particle-canvas') as HTMLCanvasElement;
    
    if (!container || !canvas || !container.dataset) return;

    // Get configuration from data attributes with safe access
    const config = {
      particleCount: parseInt(container.dataset.particleCount || '80'),
      connectionDistance: parseInt(container.dataset.connectionDistance || '150'),
      particleSpeed: parseFloat(container.dataset.particleSpeed || '0.5'),
      showConnections: container.dataset.showConnections === 'true',
      interactive: container.dataset.interactive === 'true',
      theme: container.dataset.theme || 'ai',
      opacity: parseFloat(container.dataset.opacity || '0.5')
    };

    // Create particle system
    const particleSystem = new EnhancedParticleSystem(canvas, config);

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      particleSystem.destroy();
    });
  }

  // Initialize when DOM is loaded (client-side only)
  if (typeof window !== 'undefined') {
    document.addEventListener('DOMContentLoaded', initParticleSystem);
  }
</script>
